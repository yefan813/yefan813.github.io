<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奋斗不息</title>
  
  <subtitle>态度决定一切</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yefan813.github.io/"/>
  <updated>2020-03-05T12:37:18.084Z</updated>
  <id>https://yefan813.github.io/</id>
  
  <author>
    <name>Evan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring中Bean的生命周期</title>
    <link href="https://yefan813.github.io/2020/03/05/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://yefan813.github.io/2020/03/05/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-03-05T12:15:25.000Z</published>
    <updated>2020-03-05T12:37:18.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-中-Bean-的生命周期图"><a href="#Spring-中-Bean-的生命周期图" class="headerlink" title="Spring 中 Bean 的生命周期图"></a>Spring 中 Bean 的生命周期图</h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcjbq7e3q8j30n8123agj.jpg" alt=""></p><p><a href="https://github.com/yefan813/spring-bean-life-cycle" target="_blank" rel="noopener">源码地址</a><br>项目中每个类的作用在上图中都写得非常清楚，可以下载下载直接运行看下整体效果，最好能 Debug 一下看下详细的流程。</p><p>###参考文献：<br><a href="https://www.cnblogs.com/xrq730/p/5721366.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/5721366.html</a><br><a href="https://blog.csdn.net/caihaijiang/article/details/35552859" target="_blank" rel="noopener">https://blog.csdn.net/caihaijiang/article/details/35552859</a><br><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-中-Bean-的生命周期图&quot;&gt;&lt;a href=&quot;#Spring-中-Bean-的生命周期图&quot; class=&quot;headerlink&quot; title=&quot;Spring 中 Bean 的生命周期图&quot;&gt;&lt;/a&gt;Spring 中 Bean 的生命周期图&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>chrome模拟跨域访问</title>
    <link href="https://yefan813.github.io/2020/02/11/chrome%E6%A8%A1%E6%8B%9F%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/"/>
    <id>https://yefan813.github.io/2020/02/11/chrome%E6%A8%A1%E6%8B%9F%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/</id>
    <published>2020-02-11T06:33:53.000Z</published>
    <updated>2020-02-11T06:37:31.666Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>首先随便打开一个网站</p></li><li><p>打开 console<br>输入</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var data = &#123;</span><br><span class="line">  password: &quot;xxx&quot;,</span><br><span class="line">  userName: &quot;xxx&quot;</span><br><span class="line">&#125;; </span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;post&apos;, &apos;http://127.0.0.1:8080/console/login&apos;);  </span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/json&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;SESSION_TOKEN&quot;,&quot;112233&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;CONSOLE_SESSION_TOKEN&quot;,&quot;112233&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xhr.send(JSON.stringify(data));</span><br><span class="line">xhr.onload = function(e) &#123;</span><br><span class="line">    var xhr = e.target;</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改域名、参数、header等信息即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先随便打开一个网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开 console&lt;br&gt;输入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mybatis 常见面试问题及答案</title>
    <link href="https://yefan813.github.io/2019/10/31/mybatis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>https://yefan813.github.io/2019/10/31/mybatis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</id>
    <published>2019-10-31T12:56:23.000Z</published>
    <updated>2019-12-13T09:23:25.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis面试连环炮"><a href="#Mybatis面试连环炮" class="headerlink" title="Mybatis面试连环炮"></a>Mybatis面试连环炮</h2><p>先抛出几个问题，然后带着问题一起看下 <a href="https://mybatis.org/mybatis-3/" target="_blank" rel="noopener">Mybatis官网</a>如何解释这个问题。</p><h3 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis?"></a><em>什么是Mybatis?</em></h3><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><a id="more"></a><hr><h3 id="Mybaits的优点"><a href="#Mybaits的优点" class="headerlink" title="Mybaits的优点"></a><em>Mybaits的优点</em></h3><blockquote></blockquote><ol><li>门槛低易上手</li><li>sql 可以统一写到 xml 统一管理</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写动态sql。</li></ol><hr><h3 id="Mybaits的缺点"><a href="#Mybaits的缺点" class="headerlink" title="Mybaits的缺点"></a><em>Mybaits的缺点</em></h3><blockquote></blockquote><ol><li>sql依赖于数据库，导致数据库移植性差。</li><li>缓存使用不当，容易产生脏数据。</li></ol><hr><h3 id="Mybatis全局配置文件中有哪些标签-分别代表什么意思"><a href="#Mybatis全局配置文件中有哪些标签-分别代表什么意思" class="headerlink" title="Mybatis全局配置文件中有哪些标签?分别代表什么意思?"></a><em>Mybatis全局配置文件中有哪些标签?分别代表什么意思?</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hg3nx33uj30fe0b4gnl.jpg" alt=""></p></blockquote><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hg2p0aw2j30a607wmxx.jpg" alt=""></p></blockquote><hr><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a><em>#{}和${}的区别是什么？</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hix8i6caj317t0ihgql.jpg" alt=""></p></blockquote><hr><h3 id="Mybatis-映射器引用资源方式有几种"><a href="#Mybatis-映射器引用资源方式有几种" class="headerlink" title="Mybatis 映射器引用资源方式有几种"></a>Mybatis 映射器引用资源方式有几种</h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hhyiasmvj31810jzq7i.jpg" alt=""></p></blockquote><hr><h3 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a><em>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</em></h3><p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt; </span><br><span class="line">   select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;; </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>第2种： 通过<resultmap>来映射字段名和实体类属性名的一一对应的关系</resultmap></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderresultmap&quot;&gt;</span><br><span class="line">       select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line">  &lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt; </span><br><span class="line">       &lt;!–用id属性来映射主键字段–&gt; </span><br><span class="line">       &lt;id property=”id” column=”order_id”&gt; </span><br><span class="line">       &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt; </span><br><span class="line">       &lt;result property = “orderno” column =”order_no”/&gt; </span><br><span class="line">       &lt;result property=”price” column=”order_price” /&gt; </span><br><span class="line">   &lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a><em>如何获取自动生成的(主)键值?</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hjvaw3isj31880jsjwn.jpg" alt=""></p></blockquote><hr><h3 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？"></a><em>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hjxub3t9j318a0qiafh.jpg" alt=""></p></blockquote><blockquote><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p></blockquote><p><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">传送门</a></p><hr><h3 id="Mybatis-几个关键类对象的作用域-Scope-和生命周期"><a href="#Mybatis-几个关键类对象的作用域-Scope-和生命周期" class="headerlink" title="Mybatis 几个关键类对象的作用域(Scope)和生命周期"></a>Mybatis 几个关键类对象的作用域(Scope)和生命周期</h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hg0t1yxvj317r0mqtg4.jpg" alt=""></p></blockquote><h3 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a><em>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</em></h3><blockquote><p>这是来自 Mybatis 官网一段描述<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hfm140fmj318903a3zi.jpg" alt=""><br>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。<br>如下：<br><code>&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;</code></p></blockquote><hr><h3 id="通常一个Xml映射文件，都会写一个Dao-Mapper-接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#通常一个Xml映射文件，都会写一个Dao-Mapper-接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao(Mapper)接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a><em>通常一个Xml映射文件，都会写一个Dao(Mapper)接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</em></h3><blockquote><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。</p></blockquote><blockquote><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement</p></blockquote><blockquote><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p></blockquote><p><code>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</code></p><hr><h3 id="接口绑定有几种实现方式-分别是怎么实现的"><a href="#接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="接口绑定有几种实现方式,分别是怎么实现的?"></a><em>接口绑定有几种实现方式,分别是怎么实现的?</em></h3><blockquote><ol><li>一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定</li><li>另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.</li></ol></blockquote><hr><h3 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a><em>Mybatis是如何进行分页的？分页插件的原理是什么？</em></h3><blockquote><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p></blockquote><blockquote><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p></blockquote><hr><h3 id="简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件"></a><em>简述Mybatis的插件运行原理，以及如何编写一个插件</em></h3><blockquote><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p></blockquote><blockquote><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnaapuy1j318q0ogn3c.jpg" alt=""></h2><h3 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a><em>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</em></h3><blockquote><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p></blockquote><blockquote><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p></blockquote><p><a href="https://www.cnblogs.com/ashleyboy/p/9286814.html" target="_blank" rel="noopener">延迟加载实例</a></p><hr><h3 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a><em>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</em></h3><blockquote><p>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</resultmap></p></blockquote><blockquote><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p></blockquote><hr><h3 id="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"><a href="#Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别" class="headerlink" title="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"></a><em>Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</em></h3><blockquote><p>能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p></blockquote><blockquote><p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p></blockquote><blockquote><p>那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是<resultmap>标签内的<id>子标签，指定了唯一确定一条记录的id列，Mybatis根据<id>列值来完成100条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。</id></id></id></resultmap></p></blockquote><blockquote><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnxze2t7j30p408naaw.jpg" alt=""></p><blockquote><p>官方 resultMap 文档：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnyzjlfaj318g0jidlt.jpg" alt=""></p></blockquote><hr><h3 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a><em>Mybatis是否可以映射Enum枚举类？</em></h3><p>可以<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hgj8d3icj318b0pltfz.jpg" alt=""></p><hr><h3 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a><em>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</em></h3><ol><li>SIMPLE 就是普通的执行器,每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象；</li><li>REUSE 执行器会重用预处理语句（prepared statements）,执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象</li><li>BATCH 执行器将重用语句并执行批量更新,执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ol><hr><h3 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a><em>Mybatis中如何指定使用哪一种Executor执行器？</em></h3><p>在 Mybatis xml配置文件 <setting> 中设置defaultExecutorType<br><code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;</code></setting></p><hr><h3 id="如何执行批量插入"><a href="#如何执行批量插入" class="headerlink" title="如何执行批量插入?"></a><em>如何执行批量插入?</em></h3><blockquote><ol><li><p>在 mapper.xml文件中使用<foreach></foreach></p></li><li><p>SqlSessionFactory sqlSessionFactory=getSqlSessionFactory();</p><pre><code>//可以执行批量操作的sqlSessionSqlSession openSession=sqlSessionFactory.openSession(ExecutorType.BATCH);</code></pre></li></ol></blockquote><hr><h3 id="说一下resultMap和resultType的区别"><a href="#说一下resultMap和resultType的区别" class="headerlink" title="说一下resultMap和resultType的区别"></a><em>说一下resultMap和resultType的区别</em></h3><p><strong>resultType：</strong>    从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。</p><p><strong>resultMap：</strong>    外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。</p><hr><h3 id="什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存"><a href="#什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存" class="headerlink" title="什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?"></a><em>什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?</em></h3><blockquote><ol><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li></ol></blockquote><blockquote><ol><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></li></ol></blockquote><blockquote><ol><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ol></blockquote><hr><h3 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a><em>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</em></h3><blockquote><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p></blockquote><blockquote><p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mybatis面试连环炮&quot;&gt;&lt;a href=&quot;#Mybatis面试连环炮&quot; class=&quot;headerlink&quot; title=&quot;Mybatis面试连环炮&quot;&gt;&lt;/a&gt;Mybatis面试连环炮&lt;/h2&gt;&lt;p&gt;先抛出几个问题，然后带着问题一起看下 &lt;a href=&quot;https://mybatis.org/mybatis-3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mybatis官网&lt;/a&gt;如何解释这个问题。&lt;/p&gt;
&lt;h3 id=&quot;什么是Mybatis&quot;&gt;&lt;a href=&quot;#什么是Mybatis&quot; class=&quot;headerlink&quot; title=&quot;什么是Mybatis?&quot;&gt;&lt;/a&gt;&lt;em&gt;什么是Mybatis?&lt;/em&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="mybatis" scheme="https://yefan813.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>tcc-traction源码阅读笔记</title>
    <link href="https://yefan813.github.io/2019/10/24/tcc-traction%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://yefan813.github.io/2019/10/24/tcc-traction%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2019-10-23T16:06:56.000Z</published>
    <updated>2019-12-13T09:26:27.061Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/xie-summer/tcc-transaction-v1.1.5.git" target="_blank" rel="noopener">tcc-trancation 分布式事务框架源码阅读</a></p><p><a href="https://blog.csdn.net/dm_vincent/article/details/92432059" target="_blank" rel="noopener">TCC的异常场景及应对机制</a></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1&gt;com.roncoo.pay.service.trade.biz.impl.RpTradePaymentManagerBizImpl#completeSuccessOrder 银行返回订单支付成功，后调支付成功,还未执行方法，被拦截器拦截</span><br><span class="line"> 2&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#interceptCompensableMethod 进入可事务补偿拦截器</span><br><span class="line">3&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行者类型 MethodType.ROOT</span><br><span class="line"> 4&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#rootMethodProceed  主事务方法的处理</span><br><span class="line">  5&gt;org.mengyun.tcctransaction.TransactionManager#begin 事务开始（创建事务日志记录，并将该事务日志记录存入当前线程的事务局部变量中） TransactionType.ROOT</span><br><span class="line">   6&gt;org.aspectj.lang.ProceedingJoinPoint#proceed()   Try (开始执行被拦截的方法，或进入下一个拦截器处理逻辑) ，执行完毕等待返回....</span><br><span class="line"> 7&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#interceptTransactionContextMethod  资源拦截器，拦截事务上下文方法</span><br><span class="line">  8&gt;org.mengyun.tcctransaction.TransactionManager#getCurrentTransaction 获取当前事务，没有则新建事务（trying状态）</span><br><span class="line">   9&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行者类型（ROOT）</span><br><span class="line">    10&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#generateAndEnlistRootParticipant </span><br><span class="line">生成和登记根参与者Participant（Participant保存确认方法和确认方法的实例) 加入到参与者列表，更新事务信息（加入了事务参与者，包含了触发confirm或cancel方法的参数信息）</span><br><span class="line">      11&gt;org.aspectj.lang.ProceedingJoinPoint#proceed(java.lang.Object[]) 开始执行被拦截的方法，或进入下一个拦截器处理逻辑</span><br><span class="line">12&gt;com.roncoo.pay.service.trade.biz.impl.RpTradePaymentManagerBizImpl#completeSuccessOrder 真正进入到方法内部执行 修改支付记录状态， 修改支付订单状态</span><br><span class="line"> 13&gt;com.roncoo.pay.service.account.api.RpAccountTransactionService#creditToAccountTcc 调用给商户资金帐户加款（平台收款） try 方法，调用参与者账户资金系统加款，调用之前被拦截器拦截</span><br><span class="line"> 14&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#interceptTransactionContextMethod  获取当前事务，从当前线程 threadLocal 中可以获取到事务</span><br><span class="line">  15&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行者类型，MethodType.CONSUMER</span><br><span class="line">   16&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#generateAndEnlistConsumerParticipant 生成并登记消费者的参与者Participant</span><br><span class="line">   服务接口的 TransactionContext 参数设值（新的事务分支ID），状态为当前transaction状态TRYING ,构建事务confirm上下文和构建事务cancle上下文</span><br><span class="line">    17&gt;org.aspectj.lang.ProceedingJoinPoint#proceed(java.lang.Object[]) 继续执行 方法</span><br><span class="line">     18&gt; com.roncoo.pay.service.account.api.RpAccountTransactionService#creditToAccountTcc 回到方法执行 try 方法，发起远程调用</span><br><span class="line">      19&gt;com.roncoo.pay.service.account.aip.impl.RpAccountTransactionServiceImpl#creditToAccountTcc 到了资金账户系统 provider 方真正执行方法</span><br><span class="line">       20&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#interceptCompensableMethod 被可补偿事务拦截器拦截</span><br><span class="line">        21&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行方的类型，MethodType.PROVIDER</span><br><span class="line">         22&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#providerMethodProceed 服务提供者事务方法处理. 当前分支事务状态为TRYING</span><br><span class="line">          基于全局事务ID扩展创建新的分支事务，并存于当前线程的事务局部变量中.</span><br><span class="line">          23&gt;org.aspectj.lang.ProceedingJoinPoint#proceed()开始执行被拦截的方法，或进入下一个拦截器处理逻辑</span><br><span class="line">           24&gt; org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#interceptTransactionContextMethod 进入到资源协调拦截器</span><br><span class="line">           25&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前类型为PROVIDER</span><br><span class="line">            26&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#generateAndEnlistProviderParticipant 生成并登记服务提供者的参与者 </span><br><span class="line">            构建确认方法的提交上下文，构建取消方法的提交上下文 加入参与者列表更新本地缓存</span><br><span class="line">             27&gt;org.aspectj.lang.ProceedingJoinPoint#proceed(java.lang.Object[]) 开始执行被拦截的方法，或进入下一个拦截器处理逻辑</span><br><span class="line">              28&gt;com.roncoo.pay.service.account.aip.impl.RpAccountTransactionServiceImpl#creditToAccountTcc 开始真正执行账户资金系统的 try 方法</span><br><span class="line">29&gt;com.roncoo.pay.service.trade.biz.impl.RpTradePaymentManagerBizImpl#completeSuccessOrder 账户资金加款成功，回到completeSuccessOrder方法继续执行</span><br><span class="line"> 30&gt;com.roncoo.pay.service.point.api.RpPointAccountService#creditToPointAccountTcc client调用被拦截  过程和 13 ~ 29 过程一样</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">   &gt;com.roncoo.pay.service.point.api.RpPointAccountService#creditToPointAccountTcc rpc 执行完毕返回</span><br><span class="line">    &gt; org.aspectj.lang.ProceedingJoinPoint#proceed()  执行完毕回到 步骤 6</span><br><span class="line">     &gt;org.mengyun.tcctransaction.TransactionManager#commit Try检验正常后提交（try 方法过程中如果出现异常或调用org.mengyun.tcctransaction.TransactionManager#rollback 火锅就是遍历事务参与者这列表中的 cancle 方法）(事务管理器在控制提交)：Confirm</span><br><span class="line">     &gt;org.mengyun.tcctransaction.Transaction#commit 遍历调用事务参与者列表的 commit 方法</span><br><span class="line">      &gt;org.mengyun.tcctransaction.Participant#commit</span><br><span class="line">      &gt;org.mengyun.tcctransaction.Terminator#invoke confirmInvocationContext 调用之前写入的 confirm 上线文直接执行各个参与者的 confirm 方法</span><br><span class="line">       &gt;org.mengyun.tcctransaction.TransactionRepository#delete confirm 完成后会调用事务删除方法删除日志，这里注意如果 confirm 失败了导致日志没有删除，会有个事务调度系统TransactionRecovery 定时的检索出为被删除的事务数据然后一直调用 confirm 方法去确认并记录重试次数（重试一定次数不在重试）。</span><br><span class="line">       所以接口一定要保持幂等才行 这里特别注意</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/xie-summer/tcc-transaction-v1.1.5.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tcc-trancation 分布式事务框架源码阅读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/dm_vincent/article/details/92432059&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCC的异常场景及应对机制&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java远程调试</title>
    <link href="https://yefan813.github.io/2019/10/11/java%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://yefan813.github.io/2019/10/11/java%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</id>
    <published>2019-10-11T10:29:05.000Z</published>
    <updated>2019-12-13T09:25:22.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-远程调试"><a href="#java-远程调试" class="headerlink" title="java 远程调试"></a>java 远程调试</h2><p>调试对于排查 java 各种异常问题非常重要，相信本地调试大家都很熟悉，今天分享一下如何开启远程调试。</p><ol><li><p>如果需要编译.java文件执行命令javac,生成.class文件件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac SynchronizedStudy.java</span><br></pre></td></tr></table></figure></li><li><p>执行编译过后的.class文件</p><ul><li><p>如果当前类有包路径到包的根路径下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java com.xxx.xx.SynchronizedStudy</span><br></pre></td></tr></table></figure></li><li><p>如果当前类没有包直接执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java SynchronizedStudy</span><br></pre></td></tr></table></figure></li></ul></li></ol><a id="more"></a><ol><li><p>如果要启动远程 debug 端口</p><ul><li><p>如果执行 java 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=5005 com.yefan.study.SynchronizedStudy</span><br></pre></td></tr></table></figure></li><li><p>如果执行 jar 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=5005 -jar SynchronizedStudy.jar</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>启动成功会显示如下</p><blockquote><p>Listening for transport dt_socket at address: 5005</p></blockquote><pre><code>### 远程调试命令参数说明**-Xdebug:** 启用调试特性。**-Xrunjdwp:** 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。**transport:** 这里通常使用套接字传输。**server:** 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。**address:** 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。**suspend:**如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。如果值为 n，没有调试器连接则继续执行</code></pre><h2 id="IDEA远程调试配置"><a href="#IDEA远程调试配置" class="headerlink" title="IDEA远程调试配置"></a>IDEA远程调试配置</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7unzpdz6hj30gu11o452.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7unxw0y3oj31bj0u0n35.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java-远程调试&quot;&gt;&lt;a href=&quot;#java-远程调试&quot; class=&quot;headerlink&quot; title=&quot;java 远程调试&quot;&gt;&lt;/a&gt;java 远程调试&lt;/h2&gt;&lt;p&gt;调试对于排查 java 各种异常问题非常重要，相信本地调试大家都很熟悉，今天分享一下如何开启远程调试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果需要编译.java文件执行命令javac,生成.class文件件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;javac SynchronizedStudy.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行编译过后的.class文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果当前类有包路径到包的根路径下执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java com.xxx.xx.SynchronizedStudy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果当前类没有包直接执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java SynchronizedStudy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="java javac javap 远程调试" scheme="https://yefan813.github.io/tags/java-javac-javap-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Filter 和 Interceptor 比较</title>
    <link href="https://yefan813.github.io/2018/07/31/filer-interceptor/"/>
    <id>https://yefan813.github.io/2018/07/31/filer-interceptor/</id>
    <published>2018-07-31T02:55:42.000Z</published>
    <updated>2018-08-31T07:21:10.108Z</updated>
    
    <content type="html"><![CDATA[<ol><li>过滤器（Filter）</li><li>拦截器（Interceptor</li></ol><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><ul><li><p>Filter是servlet规范中定义的java web组件, 在所有支持java web的容器中都可以使用</p></li><li><p>Filter和Filter Chain是密不可分的, Filter可以实现依次调用正是因为有了Filter Chain</p></li></ul><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ftsv1u5fihj30hh089abw.jpg" alt=""></p><p>上图是Filter对请求进行拦截的原理图, 那么java web容器(以tomcat为例子)是如何实现这个功能的呢?</p><p>下面看下Filter和Filter Chain的源码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Filter</span><br><span class="line">     public interface Filter &#123;</span><br><span class="line"></span><br><span class="line">         // 容器创建的时候调用, 即启动tomcat的时候调用</span><br><span class="line">         public void init(FilterConfig filterConfig) throws ServletException;</span><br><span class="line"></span><br><span class="line">         // 由FilterChain调用, 并且传入Filter Chain本身</span><br><span class="line">         public void doFilter(ServletRequest request, ServletResponse response,</span><br><span class="line">                 FilterChain chain) throws IOException, ServletException;</span><br><span class="line"></span><br><span class="line">         // 容器销毁的时候调用, 即关闭tomcat的时候调用</span><br><span class="line">         public void destroy();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // FilterChain</span><br><span class="line">     public interface FilterChain &#123;</span><br><span class="line"></span><br><span class="line">         // 由Filter.doFilter()中的chain.doFilter调用</span><br><span class="line">         public void doFilter(ServletRequest request, ServletResponse response)</span><br><span class="line">             throws IOException, ServletException;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li><p>正是因为Filter Chain在调用每一个Filter.doFilter()时将自身引用传递进去, 才实现了Filter的依次调用, 在Filter全部调用完之后再调用真正处理请求的servlet, 并且再次逆序回调Filter. 可能这么看还是不太明白是怎么实现Filter的顺序调用, 调用真正的servlet, 逆序调用Filter的, 一起看下Tomcat的源码就一目了然了.</p></li><li><p>在tomcat中Filter Chain的默认实现是ApplicationFilterChain, 在ApplicationFilterChain中最关键的方法就是internalDoFilter, 整个Filter流程的实现就是由这个方法完成.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// internalDoFilter(只保留关键代码)</span><br><span class="line">     private void internalDoFilter(ServletRequest request, ServletResponse response)</span><br><span class="line">         throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">         // Call the next filter if there is one</span><br><span class="line">         // pos: 当前的filter的索引, n: 调用链中所有的Filter的数量</span><br><span class="line">         // 如果调用链中还有没有调用的Filter就继续调用, 否则跳过if语句</span><br><span class="line">         if (pos &lt; n) &#123;</span><br><span class="line">             ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">             try &#123;</span><br><span class="line">                 // 获取Filter</span><br><span class="line">                 Filter filter = filterConfig.getFilter();</span><br><span class="line">                 if( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                     ...</span><br><span class="line">                     其他代码</span><br><span class="line">                     ...    </span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     // 这句话是重点, 调用Filter的doFilter方法并把Filter Chain本身传进去(this)</span><br><span class="line">                     filter.doFilter(request, response, this);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; catch (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">                 ...</span><br><span class="line">                 异常处理代码</span><br><span class="line">                 ...    </span><br><span class="line">             &#125;</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // We fell off the end of the chain -- call the servlet instance</span><br><span class="line">         try &#123;</span><br><span class="line">             ...</span><br><span class="line">             其他代码</span><br><span class="line">             ...</span><br><span class="line">             // Use potentially wrapped request from this point</span><br><span class="line">             if ((request instanceof HttpServletRequest) &amp;&amp;</span><br><span class="line">                     (response instanceof HttpServletResponse) &amp;&amp;</span><br><span class="line">                     Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                 ...</span><br><span class="line">                 其他代码</span><br><span class="line">                 ...</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                        // 调用真正的Filter</span><br><span class="line">                 servlet.service(request, response);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; catch (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">             ...</span><br><span class="line">             异常处理代码</span><br><span class="line">             ...</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">             ...</span><br><span class="line">             始终要执行的代码</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Filter的正序调用的过程和调用真正的servlet的过程了, 但是Filter的逆序调用在哪里体现了呢?</p></blockquote><ul><li>假设下面的Filter就是调用链中的最后一个Filter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">        public void doFilter(ServletRequest request, ServletResponse response,</span><br><span class="line">            FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        Log.info(&quot;before&quot;);</span><br><span class="line">             chain.doFilter(request, response);       </span><br><span class="line">            Log.info(&quot;after&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在调用chain.doFilter之后就跳过了if语句从而调用了真正的servlet, 然后internalDoFilter方法就结束(出栈)了, 紧接着就是调用Log.info(“after”)了, 然后LogFilter的doFilter就结束了(也出栈了), 紧接着就是internalDoFilter中filter.doFilter(request, response, this)的结束然后return, 然后就是调用上一个filter的chain.doFilter()之后的代码, 以此类推.</p><p>因此Filter调用链的实现其实就是一个方法调用链的过程. 刚开始, Filter Chain每调用一个Filter.doFilter()方法就是向方法调用栈中进行压栈操作(代码上的体现就是执行Filter.doFilter之前的代码), 当Filter全部调用完成之后就调用真正处理请求的servlet, 然后由方法调用链自动进行出栈操作(代码上的体现就是执行Filter.doFilter之后的代码), 从而完成整个Filter的调用链. 因为Filter功能实现实际上就是利用了方法的压栈出栈, 所以可以在调用chain.doFilter之前将方法返回, 让容器不在调用servlet方法, 从而实现权限的控制, 关键词的过滤等功能.</p><h1 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h1><ul><li>Interceptor不是servlet规范中的java web组件, 而是Spring提供的组件, 功能上和Filter差不多. 但是实现上和Filter不一样.</li></ul><p>Interceptor功能的实现主要是在Spring Mvc的DispatcherServelt.doDispatch方法中, 让我们来看看源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Interceptor的源码</span><br><span class="line">public interface HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    // 在调用真正的处理请求类之前调用</span><br><span class="line">    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line">    // 在调用真正的处理请求类之后调用</span><br><span class="line">    void postHandle(</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line"> // 在完成渲染或者出错之后调用</span><br><span class="line">    void afterCompletion(</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doDispatch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> doDispatch源码(只保留关键代码)</span><br><span class="line"></span><br><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ModelAndView mv = null;</span><br><span class="line">            Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ....</span><br><span class="line">                其它的处理代码</span><br><span class="line">                ....</span><br><span class="line"></span><br><span class="line">                // 调用拦截器的前置处理方法</span><br><span class="line">                if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Actually invoke the handler.</span><br><span class="line">                // 调用真正的处理请求的方法</span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                // 找到渲染模版</span><br><span class="line">                applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">                // 调用拦截器的后置处理方法</span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                ....</span><br><span class="line">                异常处理代码</span><br><span class="line">                ....</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            ....</span><br><span class="line">            始终要执行的代码</span><br><span class="line">            ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实看了doDispatch的关键代码, Spring Mvc对整个请求的处理流程已经很清楚了:</p><blockquote><p>调用拦截器的前置方法 -&gt; 调用处理请求的方法 -&gt; 渲染模版 -&gt; 调用拦截器的后置处理方法 -&gt; 调用拦截器的完成方法</p></blockquote><p>接下来看一看Spring Mvc是如何实现依次调用这么多拦截器的前置方法, 后置方法, 完成方法的。</p><p>进入到mapperHandler.applyPreHandle()方法中(调用拦截器的前置方法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        // 如果拦截器数组不为空</span><br><span class="line">        if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">           // 按顺序调用拦截器数组中的preHandle方法</span><br><span class="line">            for (int i = 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                // 如果拦截器的preHandle方法返回false, 则调用当前拦截器的triggerAfterCompletion方法, 然后返回, 并且不再调用后续的拦截器</span><br><span class="line">                if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">                    triggerAfterCompletion(request, response, null);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                this.interceptorIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入到mappedHandler.applyPostHandle()方法中(调用拦截器的后置方法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        // 如果拦截器数组不为空</span><br><span class="line">        if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            // 倒序调用拦截器数组中拦截器的postHandle方法</span><br><span class="line">            for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不管是否出异常triggerAfterCompletion方法始终会被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        // 拦截器数组不为空</span><br><span class="line">        if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">           // 从成功执行的最后一个拦截器开始“逆序”调用afterCompletion方法</span><br><span class="line">            for (int i = this.interceptorIndex; i &gt;= 0; i--) &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                try &#123;</span><br><span class="line">                    interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable ex2) &#123;</span><br><span class="line">                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注：triggerAfterCompletion会逆序调用afterCompletion方法</strong></p><p>看过以上三个方法之后, Spring Mvc如何处理拦截器的前置, 后置, 完成方法就一目了然了. 其实Spring Mvc就是将拦截器统一放到了拦截器数组中, 然后在调用真正的处理请求方法之前和之后正序或者倒序遍历拦截器, 同时调用拦截器的相应的方法. 最后不管是否正常结束这个流程还是出异常都会从成功的最后一个拦截器开始逆序调用afterCompletion方法</p><p>Filter 和 Inteceptor 调用流程<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ftsuzrys62j30mc0ct105.jpg" alt=""></p><p><img src="http://s2.51cto.com/wyfs02/M02/8B/3D/wKiom1hHhbmxseDtAACidU9Y84s787.png" alt=""></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li>从以上分析可以看到过滤器和拦截器实现的方式的不同. Filter是利用了方法的调用(入栈出栈)完成整个流程, 而Interceptor是利用了for循环完成了整个流程.</li><li>Filter的实现比较占用栈空间, 在Filter多的情况下可能会有栈溢出的风险存在.</li><li>Interceptor的实现逻辑更加的清晰简单</li><li>Filter组件更加的通用, 只要支持java servlet的容器都可以使用, 而Interceptor必须依赖于Spring</li><li>Filter的优先级是高于Interceptor, 即请求是先到Filter再到Interceptor的, 因为Interceptor的实现主体还是一个servlet</li><li>Filter 不能使用 spring</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;过滤器（Filter）&lt;/li&gt;
&lt;li&gt;拦截器（Interceptor&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Filter是servlet规范中定义的java web组件, 在所有支持java web的容器中都可以使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Filter和Filter Chain是密不可分的, Filter可以实现依次调用正是因为有了Filter Chain&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1ftsv1u5fihj30hh089abw.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是Filter对请求进行拦截的原理图, 那么java web容器(以tomcat为例子)是如何实现这个功能的呢?&lt;/p&gt;
&lt;p&gt;下面看下Filter和Filter Chain的源码&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Filter Interceptor 过滤器 拦截器" scheme="https://yefan813.github.io/tags/Filter-Interceptor-%E8%BF%87%E6%BB%A4%E5%99%A8-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM之 GC 调优步骤</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM4/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM4/</id>
    <published>2018-07-29T13:34:22.000Z</published>
    <updated>2018-08-31T07:24:37.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr25l9g3zj30om0e841i.jpg" alt=""></p><h2 id="初始化设置参数"><a href="#初始化设置参数" class="headerlink" title="初始化设置参数"></a>初始化设置参数</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr26pfc0wj30y008g436.jpg" alt=""></p><h2 id="Parallel-GC-调优的指导原则"><a href="#Parallel-GC-调优的指导原则" class="headerlink" title="Parallel GC 调优的指导原则"></a>Parallel GC 调优的指导原则</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr28i9o7cj30y10feq8j.jpg" alt=""></p><h2 id="G1-调优"><a href="#G1-调优" class="headerlink" title="G1 调优"></a>G1 调优</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftr2el1ajwj30zd0degrk.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr2eug0huj31030ivgqx.jpg" alt=""></p><a id="more"></a><p>参考文档：<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations" target="_blank" rel="noopener">Oracle官网</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="noopener">GC 调优指南</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html" target="_blank" rel="noopener">如何选择垃圾收集器</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations" target="_blank" rel="noopener">G1最佳实践</a><br><a href="https://zhuanlan.zhihu.com/p/22591838" target="_blank" rel="noopener">G1 GC的一些关键技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftr25l9g3zj30om0e841i.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;初始化设置参数&quot;&gt;&lt;a href=&quot;#初始化设置参数&quot; class=&quot;headerlink&quot; title=&quot;初始化设置参数&quot;&gt;&lt;/a&gt;初始化设置参数&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1ftr26pfc0wj30y008g436.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Parallel-GC-调优的指导原则&quot;&gt;&lt;a href=&quot;#Parallel-GC-调优的指导原则&quot; class=&quot;headerlink&quot; title=&quot;Parallel GC 调优的指导原则&quot;&gt;&lt;/a&gt;Parallel GC 调优的指导原则&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftr28i9o7cj30y10feq8j.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;G1-调优&quot;&gt;&lt;a href=&quot;#G1-调优&quot; class=&quot;headerlink&quot; title=&quot;G1 调优&quot;&gt;&lt;/a&gt;G1 调优&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftr2el1ajwj30zd0degrk.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1ftr2eug0huj31030ivgqx.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="GC" scheme="https://yefan813.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC日志分析工具</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM3/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM3/</id>
    <published>2018-07-29T13:14:10.000Z</published>
    <updated>2018-07-29T13:17:23.839Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在线工具：<a href="http://gceasy.io" target="_blank" rel="noopener">http://gceasy.io</a></p></li><li><p>GCViewer</p></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr1n1v45qj30ww0ddaey.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;在线工具：&lt;a href=&quot;http://gceasy.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://gceasy.io&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCViewer&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="GC" scheme="https://yefan813.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾回收算法</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM2/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM2/</id>
    <published>2018-07-29T09:59:14.000Z</published>
    <updated>2018-08-31T07:24:30.084Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqvzd2erdj30zs0datd1.jpg" alt=""></p><p>##标记清楚算法(Mark-Sweep)<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqw93v8ldj30y30ba789.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ftqwdlfu4cj30p40dq0us.jpg" alt=""></p><p>##复制算法(Copying)<br>为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqwirry1nj30l00blac4.jpg" alt=""></p><p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。</p><a id="more"></a><h2 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h2><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqwkj0puvj30ld0cb75n.jpg" alt=""></p><p>缺点：没有内存碎片，但是整理内存比较耗时</p><h2 id="分代收集算法-Generational-Collection"><a href="#分代收集算法-Generational-Collection" class="headerlink" title="分代收集算法(Generational Collection)"></a>分代收集算法(Generational Collection)</h2><p>分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><p>目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftqwmjpuyvj30kg046wfh.jpg" alt=""></p><p>而老生代因为每次只回收少量对象，因而采用Mark-Compact算法。</p><p>另外，不要忘记在<a href="http://www.cnblogs.com/cielosun/p/6622983.html" target="_blank" rel="noopener">Java基础：Java虚拟机(JVM)</a>中提到过的处于方法区的永生代(Permanet Generation)。它用来存储class类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</p><p>对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。如果To Space无法足够存储某个对象，则将这个对象存储到老生代。在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。</p><h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h1><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqwuiheq8j30wl0agq70.jpg" alt=""></p><h1 id="典型的垃圾收集器"><a href="#典型的垃圾收集器" class="headerlink" title="典型的垃圾收集器"></a>典型的垃圾收集器</h1><p>垃圾收集算法是垃圾收集器的理论基础，而垃圾收集器就是其具体实现。下面介绍HotSpot虚拟机提供的几种垃圾收集器。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzmigfi8j30zu08o41k.jpg" alt=""></p><ol><li><p><strong>Serial/Serial Old</strong><br>最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。</p></li><li><p><strong>ParNew</strong><br>Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集。</p></li><li><p><strong>Parallel Scavenge</strong><br>新生代的<strong>并行</strong>收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。</p></li><li><p><strong>Parallel Old</strong><br>Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程。</p></li><li><p><strong>CMS</strong><br>Current Mark Sweep收集器是一种以最小回收时间停顿为目标的<strong>并发</strong>回收器，因而采用Mark-Sweep算法。</p></li><li><p><strong>G1</strong><br>G1(Garbage First)收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。</p></li></ol><h2 id="这里要强调一下并行与并发的概念："><a href="#这里要强调一下并行与并发的概念：" class="headerlink" title="这里要强调一下并行与并发的概念："></a>这里要强调一下并行与并发的概念：</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzpiq83bj30z80clwlo.jpg" alt=""></p><h2 id="停顿时间-VS-吞吐量"><a href="#停顿时间-VS-吞吐量" class="headerlink" title="停顿时间 VS 吞吐量"></a>停顿时间 VS 吞吐量</h2><p> <img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzrdxmovj30w908rdjq.jpg" alt=""></p><h1 id="垃圾收集器搭配"><a href="#垃圾收集器搭配" class="headerlink" title="垃圾收集器搭配"></a>垃圾收集器搭配</h1><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzwboe8qj30rc0jkdpn.jpg" alt=""></p><h1 id="垃圾收集器详解："><a href="#垃圾收集器详解：" class="headerlink" title="垃圾收集器详解："></a>垃圾收集器详解：</h1><h2 id="并行垃圾收集器（Parallel-Collector）"><a href="#并行垃圾收集器（Parallel-Collector）" class="headerlink" title="并行垃圾收集器（Parallel Collector）"></a>并行垃圾收集器（Parallel Collector）</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqzz6v7u4j30ri08jtb3.jpg" alt=""></p><h2 id="CMS-垃圾收集器"><a href="#CMS-垃圾收集器" class="headerlink" title="CMS 垃圾收集器"></a>CMS 垃圾收集器</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr01s112jj30hl09m3zp.jpg" alt=""></p><h3 id="CMS-垃圾收集过程"><a href="#CMS-垃圾收集过程" class="headerlink" title="CMS 垃圾收集过程"></a>CMS 垃圾收集过程</h3><ol><li>CMS initialmark： 初始化标记Root， stop the world</li><li>CMS concurrent mark：并发标记</li><li>CMS concurrent preclean：并发预清理</li><li>CMS remark ：重新标记。 stop the world</li><li>CMS concurrent sweep：并发清除</li><li>CMS concurrent reset： 并发重置</li></ol><h3 id="CMS-缺点"><a href="#CMS-缺点" class="headerlink" title="CMS 缺点"></a>CMS 缺点</h3><p>CPU 敏感<br>浮动垃圾<br>空间碎片</p><h3 id="CMS-相关参数"><a href="#CMS-相关参数" class="headerlink" title="CMS 相关参数"></a>CMS 相关参数</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr07yp4fbj30zm0awq6l.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr093dpxoj30yl0dgaep.jpg" alt=""></p><h2 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h2><p>新生代和老年代垃圾收集器</p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftr0dqxjbkj30yf0bd793.jpg" alt=""> </p><h3 id="Mixed-GC："><a href="#Mixed-GC：" class="headerlink" title="Mixed GC："></a>Mixed GC：</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr0fw6h38j30pu05tmyk.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr0gtvi2xj30w80a4dj2.jpg" alt=""></p><h3 id="Mixed-GC-时机："><a href="#Mixed-GC-时机：" class="headerlink" title="Mixed GC 时机："></a>Mixed GC 时机：</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr0hcs8tuj30zc0gjn4x.jpg" alt=""></p><h3 id="Mixed-GC-相关参数："><a href="#Mixed-GC-相关参数：" class="headerlink" title="Mixed GC 相关参数："></a>Mixed GC 相关参数：</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr0j7fupxj30xt0g479o.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr0k5ocwdj30uu04ljt9.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr0lktqmpj30ya0dvwka.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr0mm2vpej30uk0dcn1c.jpg" alt=""></p><p> 参考文章：</p><p> <a href="https://www.cnblogs.com/cielosun/p/6674431.html" target="_blank" rel="noopener">JVM垃圾回收算法</a></p><p> <a href="https://blog.csdn.net/aijiudu/article/details/72991993" target="_blank" rel="noopener">JVM架构和GC垃圾回收机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1ftqvzd2erdj30zs0datd1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##标记清楚算法(Mark-Sweep)&lt;br&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftqw93v8ldj30y30ba789.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1ftqwdlfu4cj30p40dq0us.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##复制算法(Copying)&lt;br&gt;为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftqwirry1nj30l00blac4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JVM 垃圾回收 算法" scheme="https://yefan813.github.io/tags/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM之内存结构</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM1/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM1/</id>
    <published>2018-07-29T09:30:38.000Z</published>
    <updated>2018-08-31T07:24:26.380Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqvmlyu0uj30tu0l3tfs.jpg" alt=""></p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqv5mutquj30qy0e9q6b.jpg" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqv92b52xj30z30ajdlk.jpg" alt=""><br><strong>注：线程私有</strong></p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqvbjk29mj30z10b60zf.jpg" alt=""><br><strong>注：线程私有</strong></p><a id="more"></a><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqvd5nd5dj30yw0agwk4.jpg" alt=""></p><p><strong>注：线程共享</strong></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqvghydnpj30xj08243t.jpg" alt=""></p><p><strong>注：线程共享，JDK8中是 Meta Space ，在 JDK8之前是 Perm Space 永久区</strong></p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqvin3ygbj30xv07ejwv.jpg" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftqvkjcrq6j30x806mgpu.jpg" alt=""></p><h3 id="非堆区"><a href="#非堆区" class="headerlink" title="非堆区"></a>非堆区</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftqvpdj5i8j30xe0eagpu.jpg" alt=""></p><p>参考文章：<br><a href="https://blog.csdn.net/aijiudu/article/details/72991993" target="_blank" rel="noopener">JVM架构和GC垃圾回收机制</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">jvm的运行时数据区</a><br><a href="http://ifeve.com/jvm-troubleshooting-guide-4/" target="_blank" rel="noopener">Metaspace</a><br><a href="https://blog.csdn.net/jijijijwwi111/article/details/51564271" target="_blank" rel="noopener">压缩类空间</a><br><a href="https://blog.csdn.net/yandaonan/article/details/50844806" target="_blank" rel="noopener">codecache</a><br><a href="http://engineering.indeedblog.com/blog/2016/09/job-search-web-app-java-8-migration/" target="_blank" rel="noopener">codecache2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftqvmlyu0uj30tu0l3tfs.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行时数据区&quot;&gt;&lt;a href=&quot;#运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区&quot;&gt;&lt;/a&gt;运行时数据区&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftqv5mutquj30qy0e9q6b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftqv92b52xj30z30ajdlk.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;注：线程私有&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;虚拟机栈&quot;&gt;&lt;a href=&quot;#虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈&quot;&gt;&lt;/a&gt;虚拟机栈&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftqvbjk29mj30z10b60zf.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;注：线程私有&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JVM 内存结构" scheme="https://yefan813.github.io/tags/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之六：JVM Heap Dump（堆转储文件）的生成和内存分析工具MAT的使用</title>
    <link href="https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%906/"/>
    <id>https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%906/</id>
    <published>2018-07-26T10:06:22.000Z</published>
    <updated>2018-08-31T07:24:15.684Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/30/53562102.html" target="_blank" rel="noopener">传送门</a></p><p>前面的文章详细讲述了分析Thread Dump文件，实际在处理Java内存泄漏问题的时候，还需要分析JVM堆转储文件来进行定位</p><h2 id="JVM-Heap-Dump（堆转储文件）的生成"><a href="#JVM-Heap-Dump（堆转储文件）的生成" class="headerlink" title="JVM Heap Dump（堆转储文件）的生成"></a>JVM Heap Dump（堆转储文件）的生成</h2><p>正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况。<br>可以通过以下几种方式生成Heap Dump文件：</p><h3 id="使用-jmap-命令生成"><a href="#使用-jmap-命令生成" class="headerlink" title="使用 jmap 命令生成"></a>使用 jmap 命令生成</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html" target="_blank" rel="noopener">jmap</a> 命令是JDK提供的用于生成堆内存信息的工具，可以执行下面的命令生成Heap Dump：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap-dump.bin &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>其中的pid是JVM进程的id，<strong>heap-dump.bin</strong>是生成的文件名称，在执行命令的目录下面。推荐此种方法。</p><h3 id="使用-JConsole-生成"><a href="#使用-JConsole-生成" class="headerlink" title="使用 JConsole 生成"></a>使用 JConsole 生成</h3><p>JConsole是JDK提供的一个基于GUI查看JVM系统信息的工具，既可以管理本地的JVM，也可以管理远程的JVM，可以通过下图的 <strong>dumpHeap</strong> 按钮生成 Heap Dump文件。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/c78c2ca6e71557f5fd118a0a4f80903f.png" alt=""></p><h2 id="在JVM中增加参数生成"><a href="#在JVM中增加参数生成" class="headerlink" title="在JVM中增加参数生成"></a>在JVM中增加参数生成</h2><p>在JVM的配置参数中可以添加 <strong>-XX:+HeapDumpOnOutOfMemoryError</strong> 参数，当应用抛出 OutOfMemoryError 时自动生成dump文件；<br>在JVM的配置参数中添加 <strong>-Xrunhprof:head=site</strong> 参数，会生成java.hprof.txt 文件，不过这样会影响JVM的运行效率，不建议在生产环境中使用（未亲测）。</p><h2 id="常见的Heap-Dump文件分析工具"><a href="#常见的Heap-Dump文件分析工具" class="headerlink" title="常见的Heap Dump文件分析工具"></a>常见的Heap Dump文件分析工具</h2><p>JVM Heap Dump文件可以使用常用的分析工具如下：</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html" target="_blank" rel="noopener">jhat</a> 是JDK自带的用于分析JVM Heap Dump文件的工具，使用下面的命令可以将堆文件的分析结果以HTML网页的形式进行展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat &lt;heap-dump-file&gt;</span><br></pre></td></tr></table></figure><p>其中 heap-dump-file 是文件的路径和文件名，可以使用 <strong>-J-Xmx512m</strong> 参数设置命令的内存大小。执行成功之后显示如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p>这个时候访问 <a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a> 就可以看到结果了。</p><h3 id="Eclipse-Memory-Analyzer-MAT"><a href="#Eclipse-Memory-Analyzer-MAT" class="headerlink" title="Eclipse Memory Analyzer(MAT)"></a>Eclipse Memory Analyzer(MAT)</h3><p><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">Eclipse Memory Analyzer(MAT)</a>是Eclipse提供的一款用于Heap Dump文件的工具，操作简单明了，下面将详细进行介绍。</p><h3 id="IBM-Heap-Analyzer"><a href="#IBM-Heap-Analyzer" class="headerlink" title="IBM Heap Analyzer"></a>IBM Heap Analyzer</h3><p><a href="https://www.ibm.com/developerworks/community/alphaworks/tech/heapanalyzer" target="_blank" rel="noopener">IBM Heap Analyzer</a> 是IBM公司推出的一款用于分析Heap Dump信息的工具，下载之后是一个jar文件，执行结果如下：</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/9ab49abb09fb99a66bf2612989e630c2.png" alt=""></p><h2 id="Memory-Analyzer的安装和使用"><a href="#Memory-Analyzer的安装和使用" class="headerlink" title="Memory Analyzer的安装和使用"></a>Memory Analyzer的安装和使用</h2><p>如前文所述，Eclipse Memory Analyzer（简称MAT）是一个功能丰富且操作简单的JVM Heap Dump分析工具，可以用来辅助发现内存泄漏减少内存占用。<br>使用 Memory Analyzer 来分析生产环境的 Java 堆转储文件，可以从数以百万计的对象中快速计算出对象的 Retained Size，查看是谁在阻止垃圾回收，并自动生成一个 Leak Suspect（内存泄露可疑点）报表。</p><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>Eclipse Memory Analyzer（MAT）支持两种安装方式，一是Eclipse插件的方式，另外一个就是独立运行的方式，建议使用独立运行的方式。<br>在 <a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">http://www.eclipse.org/mat/downloads.php</a> 下载安装MAT，启动之后打开 File - Open Heap Dump… 菜单，然后选择生成的Heap DUmp文件，选择 “Leak Suspects Report”，然后点击 “Finish” 按钮。<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/7ac5ffafea8488aa36df72fd0a8a2df6.png" alt=""></p><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>第一次打开因为需要分析dump文件，所以需要等待一段时间进行分析，分析完成之后dump文件目录下面的文件信息如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/56ae33d76a59bff56b92de705f3e0fc1.png" alt=""></p><p>上图中 heap-27311.bin 文件是原始的Heap Dump文件，zip文件是生成的html形式的报告文件。</p><p>打开之后，主界面如下所示：</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/47fb011d433ddf4c295f4718adc8b4b5.png" alt=""></p><p>接下来介绍界面中常用到的功能：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/843eb07db5728ab786cfbcb016d6809f.png" alt=""></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Overview视图，即概要界面，显示了概要的信息，并展示了MAT常用的一些功能。</p><ul><li>Details 显示了一些统计信息，包括整个堆内存的大小、类（Class）的数量、对象（Object）的数量、类加载器（Class Loader)的数量。</li><li>Biggest Objects by Retained Size 使用饼图的方式直观地显示了在JVM堆内存中最大的几个对象，当光标移到饼图上的时候会在左边Inspector和Attributes窗口中显示详细的信息。</li><li>Actions 这里显示了几种常用到的操作，算是功能的快捷方式，包括 Histogram、Dominator Tree、Top Consumers、Duplicate Classes，具体的含义和用法见下面；</li><li>Reports 列出了常用的报告信息，包括 Leak Suspects和Top Components，具体的含义和内容见下；</li><li>Step By Step 以向导的方式引导使用功能。</li></ul><h3 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h3><p>直方图，可以查看每个类的实例（即对象）的数量和大小。</p><h3 id="Dominator-Tree"><a href="#Dominator-Tree" class="headerlink" title="Dominator Tree"></a>Dominator Tree</h3><p>支配树，列出Heap Dump中处于活跃状态中的最大的几个对象，默认按 retained size进行排序，因此很容易找到占用内存最多的对象。</p><h3 id="OQL"><a href="#OQL" class="headerlink" title="OQL"></a>OQL</h3><p>MAT提供了一个对象查询语言（OQL），跟SQL语言类似，将类当作表、对象当作记录行、成员变量当作表中的字段。通过OQL可以方便快捷的查询一些需要的信息，是一个非常有用的工具。</p><h3 id="Thread-Overview"><a href="#Thread-Overview" class="headerlink" title="Thread Overview"></a>Thread Overview</h3><p>此工具可以查看生成Heap Dump文件的时候线程的运行情况，用于线程的分析。</p><h3 id="Run-Expert-System-Test"><a href="#Run-Expert-System-Test" class="headerlink" title="Run Expert System Test"></a>Run Expert System Test</h3><p>可以查看分析完成的HTML形式的报告，也可以打开已经产生的分析报告文件，子菜单项如下图所示<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/22d20d2d807b24c859b795846f587922.png" alt=""></p><p>常用的主要有Leak Suspects和Top Components两种报告：</p><ul><li>Leak Suspects 可以说是非常常用的报告了，该报告分析了 Heap Dump并尝试找出内存泄漏点，最后在生成的报告中对检测到的可疑点做了详细的说明；</li><li>Top Components 列出占用总堆内存超过1%的对象。</li></ul><h3 id="Open-Query-Browser"><a href="#Open-Query-Browser" class="headerlink" title="Open Query Browser"></a>Open Query Browser</h3><p>提供了在分析过程中用到的工具，通常都集成在了右键菜单中，在后面具体举例分析的时候会做详细的说明。如下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/c9f7a5b311c473627ddd281f52907e0a.png" alt=""><br>这里仅针对在 Overview 界面中的 Acations中列出的两项进行说明：</p><p>Top Consumers 按类、类加载器和包分别进行查询，并以饼图的方式列出最大的几个对象。菜单打开方式如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/5e7a1762e03b51c263cb713f64461135.png" alt=""></p><p>Duplicate Classes 列出被加载多次的类，结果按类加载器进行分组，目标是加载同一个类多次被类加载器加载。使用该工具很容易找到部署应用的时候使用了同一个库的多个版本。菜单打开方式如下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/cc8cbe62f8e41bb9da95edeba1a25a1b.png" alt=""></p><h3 id="Find-Object-by-address"><a href="#Find-Object-by-address" class="headerlink" title="Find Object by address"></a>Find Object by address</h3><p>通过十六进制的地址查找对应的对象，见下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/27e4a4532a75590d7e3a66f7101c9240.png" alt=""></p><p>参考资料：<br><a href="http://blog.csdn.net/zapldy/article/details/7727572" target="_blank" rel="noopener">利用MemoryAnalyzer进行OutOfMemoryError的诊断分析</a><br><a href="https://eclipsesource.com/blogs/2013/01/21/10-tips-for-using-the-eclipse-memory-analyzer/" target="_blank" rel="noopener">10 Tips for using the Eclipse Memory Analyzer</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/" target="_blank" rel="noopener">使用 Eclipse Memory Analyzer 进行堆转储文件分析</a><br><a href="http://www.cnblogs.com/xianzhedeyu/p/5800666.html" target="_blank" rel="noopener">Java内存分析</a><br><a href="http://tivan.iteye.com/blog/1487855" target="_blank" rel="noopener">一次使用Eclipse Memory Analyzer分析Tomcat内存溢出</a><br><a href="http://wensong.iteye.com/blog/1986449" target="_blank" rel="noopener">Memory Analyzer Tool 使用手记</a><br><a href="http://www.zhyea.com/2016/07/17/memory-analyzer-all.html" target="_blank" rel="noopener">MemoryAnalyzer介绍及使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/30/53562102.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面的文章详细讲述了分析Thread Dump文件，实际在处理Java内存泄漏问题的时候，还需要分析JVM堆转储文件来进行定位&lt;/p&gt;
&lt;h2 id=&quot;JVM-Heap-Dump（堆转储文件）的生成&quot;&gt;&lt;a href=&quot;#JVM-Heap-Dump（堆转储文件）的生成&quot; class=&quot;headerlink&quot; title=&quot;JVM Heap Dump（堆转储文件）的生成&quot;&gt;&lt;/a&gt;JVM Heap Dump（堆转储文件）的生成&lt;/h2&gt;&lt;p&gt;正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况。&lt;br&gt;可以通过以下几种方式生成Heap Dump文件：&lt;/p&gt;
&lt;h3 id=&quot;使用-jmap-命令生成&quot;&gt;&lt;a href=&quot;#使用-jmap-命令生成&quot; class=&quot;headerlink&quot; title=&quot;使用 jmap 命令生成&quot;&gt;&lt;/a&gt;使用 jmap 命令生成&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jmap&lt;/a&gt; 命令是JDK提供的用于生成堆内存信息的工具，可以执行下面的命令生成Heap Dump：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MAT 内存泄漏" scheme="https://yefan813.github.io/tags/MAT-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之五：常见的Thread Dump日志案例分析</title>
    <link href="https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%905/"/>
    <id>https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%905/</id>
    <published>2018-07-26T09:10:11.000Z</published>
    <updated>2018-08-31T07:24:12.229Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/26/08572060.html" target="_blank" rel="noopener">传送门</a></p><h2 id="症状及解决方案"><a href="#症状及解决方案" class="headerlink" title="症状及解决方案"></a>症状及解决方案</h2><p>下面列出几种常见的症状即对应的解决方案：</p><h3 id="CPU占用率很高，响应很慢"><a href="#CPU占用率很高，响应很慢" class="headerlink" title="CPU占用率很高，响应很慢"></a>CPU占用率很高，响应很慢</h3><p>按照<a href="https://yefan813.github.io/2018/07/25/jstack%E4%BD%BF%E7%94%A8/">《Java内存泄漏分析系列之一：使用jstack定位线程堆栈信息》</a>中所说的方法，先找到占用CPU的进程，然后再定位到对应的线程，最后分析出对应的堆栈信息。<br>在同一时间多次使用上述的方法，然后进行对比分析，从代码中找到问题所在的原因。如果线程指向的是”VM Thread”或者无法从代码中直接找到原因，就需要进行内存分析，具体的见下一篇文章。</p><a id="more"></a><h3 id="CPU占用率不高，但响应很慢"><a href="#CPU占用率不高，但响应很慢" class="headerlink" title="CPU占用率不高，但响应很慢"></a>CPU占用率不高，但响应很慢</h3><p>在整个请求的过程中多次执行Thread Dump然后进行对比，取得<strong>BLOCKED</strong> 状态的线程列表，通常是因为线程停在了I/O、数据库连接或网络连接的地方。</p><h3 id="关注点概况"><a href="#关注点概况" class="headerlink" title="关注点概况"></a>关注点概况</h3><p>在Thread Dump文件中，线程的状态分成两种：<strong>Native Thread Status（系统线程状态）</strong>和<strong>JVM Thread Status（JVM 线程状态）</strong>，具体的含义可以参考<a href="https://yefan813.github.io/2018/07/26/jstack3/">上一篇文章</a>。在分析日志的时候需要重点关注如下几种线程状态：</p><h3 id="系统线程状态为-deadlock"><a href="#系统线程状态为-deadlock" class="headerlink" title="系统线程状态为 deadlock"></a>系统线程状态为 deadlock</h3><p>线程处于死锁状态，将占用系统大量资源。</p><h3 id="系统线程状态为-waiting-for-monitor-entry-或-in-Object-wait"><a href="#系统线程状态为-waiting-for-monitor-entry-或-in-Object-wait" class="headerlink" title="系统线程状态为 waiting for monitor entry 或 in Object.wait()"></a>系统线程状态为 waiting for monitor entry 或 in Object.wait()</h3><p>如上一篇文章中所说，系统线程处于这种状态说明它在等待进入一个临界区，此时JVM线程的状态通常都是 <strong>java.lang.Thread.State: BLOCKED。</strong></p><p>如果大量线程处于这种状态的话，可能是一个全局锁阻塞了大量线程。如果短期内多次打印Thread Dump信息，发现<strong>waiting for monitor entry</strong>状态的线程越来越多，没有减少的趋势，可能意味着某些线程在临界区里呆得时间太长了，以至于越来越多新线程迟迟无法进入。</p><h3 id="系统线程状态为-waiting-on-condition"><a href="#系统线程状态为-waiting-on-condition" class="headerlink" title="系统线程状态为 waiting on condition"></a>系统线程状态为 waiting on condition</h3><p>系统线程处于此种状态说明它在等待另一个条件的发生来唤醒自己，或者自己调用了sleep()方法。此时JVM线程的状态通常是java.lang.Thread.State: WAITING (parking)（等待唤醒条件）或java.lang.Thread.State: TIMED_WAITING (parking或sleeping)（等待定时唤醒条件）。</p><p>如果大量线程处于此种状态，说明这些线程又去获取第三方资源了，比如第三方的网络资源或读取数据库的操作，长时间无法获得响应，导致大量线程进入等待状态。因此，这说明系统处于一个网络瓶颈或读取数据库操作时间太长。</p><h3 id="系统线程状态为-blocked"><a href="#系统线程状态为-blocked" class="headerlink" title="系统线程状态为 blocked"></a>系统线程状态为 blocked</h3><p>线程处于阻塞状态，需要根据实际情况进行判断。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>下面通过几个案例进行分解来获得解决问题的方法。</p><h3 id="waiting-for-monitor-entry-和-java-lang-Thread-State-BLOCKED"><a href="#waiting-for-monitor-entry-和-java-lang-Thread-State-BLOCKED" class="headerlink" title="waiting for monitor entry 和 java.lang.Thread.State: BLOCKED"></a>waiting for monitor entry 和 java.lang.Thread.State: BLOCKED</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;DB-Processor-13&quot; daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:102)</span><br><span class="line">                - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)</span><br><span class="line">                at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)</span><br><span class="line"></span><br><span class="line">&quot;DB-Processor-14&quot; daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f020]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:102)</span><br><span class="line">                - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)</span><br><span class="line">                at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)</span><br><span class="line"></span><br><span class="line">&quot;DB-Processor-3&quot; daemon prio=5 tid=0x00928248 nid=0x8b waiting for monitor entry [0x000000000825d080]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">                at oracle.jdbc.driver.OracleConnection.isClosed(OracleConnection.java:570)</span><br><span class="line">                - waiting to lock &lt;0xe03ba2e0&gt; (a oracle.jdbc.driver.OracleConnection)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:112)</span><br><span class="line">                - locked &lt;0xe0386580&gt; (a java.util.Vector)</span><br><span class="line">                - locked &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.Cue_1700c.GetNationList(Cue_1700c.java:66)</span><br><span class="line">                at org.apache.jsp.cue_1700c_jsp._jspService(cue_1700c_jsp.java:120)</span><br></pre></td></tr></table></figure><p>上面系统线程的状态是 <strong>waiting for monitor entry</strong>，说明此线程通过 synchronized(obj) { } 申请进入临界区，但obj对应的 Monitor 被其他线程所拥有，所以 JVM线程的状态是 <strong>java.lang.Thread.State: BLOCKED (on object monitor)</strong>，说明线程等待资源超时。</p><p>下面的 <strong>waiting to lock <0xe0375410></0xe0375410></strong> 说明线程在等待给 <strong>0xe0375410</strong> 这个地址上锁（<strong>trying to obtain 0xe0375410 lock</strong>），如果在日志中发现有大量的线程都在等待给 现有大量的线程都在等 上锁的话，这个时候需要在日志中查找那个线程获取了这个锁 <strong>locked <0xe0375410></0xe0375410></strong>，如上面的例子中是 <strong>“DB-Processor-14”</strong> 这个线程，这样就可以顺藤摸瓜了。上面的例子是因为获取数据库操作等待的时间太长所致的，这个时候就需要修改数据库连接的配置信息。</p><p>如果两个线程相互都被对方的线程锁锁住，这样就造成了 <strong>死锁</strong> 现象，如下面的例子所示：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-deadlock-1.png" alt=""></p><h3 id="waiting-on-condition-和-java-lang-Thread-State-TIMED-WAITING"><a href="#waiting-on-condition-和-java-lang-Thread-State-TIMED-WAITING" class="headerlink" title="waiting on condition 和 java.lang.Thread.State: TIMED_WAITING"></a>waiting on condition 和 java.lang.Thread.State: TIMED_WAITING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">                at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">                - parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">                at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>JVM线程的状态是 java.lang.Thread.State: TIMED_WAITING (parking)，说明线程处于定时等待的状态，parking指线程处于挂起中。</p><p><strong>waiting on condition</strong>需要结合堆栈中的 parking to wait for <0x00000000acd84de8> (a java.util.concurrent.SynchronousQueue$TransferStack) 一起来分析。首先，本线程肯定是在等待某个条件的发生来把自己唤醒。其次，SynchronousQueue并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中的时候必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。</0x00000000acd84de8></p><p>in Object.wait() 和 java.lang.Thread.State: TIMED_WAITING</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI RenewClean-[172.16.5.19:28475]&quot; daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">                at java.lang.Object.wait(Native Method)</span><br><span class="line">                - waiting on &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">                at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</span><br><span class="line">                - locked &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">                at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>本例中JVM线程的状态是 <strong>java.lang.Thread.State: TIMED_WAITING (on object monitor)</strong>，说明线程调用了 <strong>java.lang.Object.wait(long timeout)</strong> 方法而进入了等待状态。</p><p>“Wait Set”中等待的线程状态就是 <strong>in Object.wait()</strong>，当线程获得了 Monitor进入临界区之后，如果发现线程继续运行的条件没有满足，它就调用对象（通常是被 synchronized 的对象）的wait()方法，放弃了Monitor，进入 “Wait Set” 队列中。只有当别的线程在该对象上调用了 notify()或notifyAll()方法， “Wait Set” 队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到的运行态。</p><p>另外需要注意的是，是先 locked <0x00000000aa672478> 然后再 waiting on <0x00000000aa672478>，之所以如此，可以通过下面的代码进行演示：</0x00000000aa672478></0x00000000aa672478></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static private class  Lock &#123; &#125;;</span><br><span class="line">private Lock lock = new Lock();</span><br><span class="line">public Reference&lt;? extends T&gt; remove(long timeout) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">        if (r != null) return r;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            // ……</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在执行的过程中，先用 synchronized 获得了这个对象的 Monitor（对应 locked <0x00000000aa672478>），当执行到 <strong>lock.wait(timeout);</strong> 的时候，线程就放弃了Monitor的所有权，进入 “Wait Set” 队列（对应 waiting on <0x00000000aa672478>）。</0x00000000aa672478></0x00000000aa672478></p><p>前面几篇文章详细说明了如何分析Thread Dump文件，除此之外还可以通过分析JVM堆内存信息来进一步找到问题的原因。</p><p>参考资料：<br><a href="http://just2do.iteye.com/blog/2275894" target="_blank" rel="noopener">性能分析之– JAVA Thread Dump 分析综述</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">三个实例演示 Java Thread Dump 日志分析</a><br><a href="http://sesame.iteye.com/blog/428012" target="_blank" rel="noopener">如何分析Java虚拟机死锁</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/03/18/tda.html" target="_blank" rel="noopener">各种 Java Thread State 第一分析法则</a><br><a href="https://dzone.com/articles/how-analyze-java-thread-dumps" target="_blank" rel="noopener">How to Analyze Java Thread Dumps | 中文版</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr034.html" target="_blank" rel="noopener">官网</a><br><a href="https://mp.weixin.qq.com/s/GsxeFM7QWuR--Kbpb7At2w" target="_blank" rel="noopener">java线程状态转化</a><br><a href="https://blogs.oracle.com/poonam/understanding-cms-gc-logs" target="_blank" rel="noopener">CMS日志格式</a><br><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">G1日志格式</a><br><a href="http://gceasy.io/" target="_blank" rel="noopener">GC日志分析工具</a><br><a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener">GCViewer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/26/08572060.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;症状及解决方案&quot;&gt;&lt;a href=&quot;#症状及解决方案&quot; class=&quot;headerlink&quot; title=&quot;症状及解决方案&quot;&gt;&lt;/a&gt;症状及解决方案&lt;/h2&gt;&lt;p&gt;下面列出几种常见的症状即对应的解决方案：&lt;/p&gt;
&lt;h3 id=&quot;CPU占用率很高，响应很慢&quot;&gt;&lt;a href=&quot;#CPU占用率很高，响应很慢&quot; class=&quot;headerlink&quot; title=&quot;CPU占用率很高，响应很慢&quot;&gt;&lt;/a&gt;CPU占用率很高，响应很慢&lt;/h3&gt;&lt;p&gt;按照&lt;a href=&quot;https://yefan813.github.io/2018/07/25/jstack%E4%BD%BF%E7%94%A8/&quot;&gt;《Java内存泄漏分析系列之一：使用jstack定位线程堆栈信息》&lt;/a&gt;中所说的方法，先找到占用CPU的进程，然后再定位到对应的线程，最后分析出对应的堆栈信息。&lt;br&gt;在同一时间多次使用上述的方法，然后进行对比分析，从代码中找到问题所在的原因。如果线程指向的是”VM Thread”或者无法从代码中直接找到原因，就需要进行内存分析，具体的见下一篇文章。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JVM 内存泄露" scheme="https://yefan813.github.io/tags/JVM-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之三：jstack生成的Thread Dump日志线程状态</title>
    <link href="https://yefan813.github.io/2018/07/26/jstack3/"/>
    <id>https://yefan813.github.io/2018/07/26/jstack3/</id>
    <published>2018-07-26T02:57:37.000Z</published>
    <updated>2018-08-31T07:24:02.277Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/20/12131956.html" target="_blank" rel="noopener">传送门</a></p><p>前面<a href="https://yefan813.github.io/2018/07/25/jstack2/">文章</a>中只分析了Thread Dump日志文件的结构，今天针对日志文件中 Java EE middleware, third party &amp; custom application Threads 部分线程的状态进行详细的分析。</p><a id="more"></a><h2 id="Thread-Dump日志的线程信息"><a href="#Thread-Dump日志的线程信息" class="headerlink" title="Thread Dump日志的线程信息"></a>Thread Dump日志的线程信息</h2><p>以下面的日志为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;resin-22129&quot; daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:315)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.park(ResinThread2.java:196)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.runTasks(ResinThread2.java:147)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.run(ResinThread2.java:118)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;Timer-20&quot; daemon prio=10 tid=0x00007fe3a4bfb800 nid=0x1a31 in Object.wait() [0x00007fe3a077a000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)</span><br><span class="line">    at java.util.TimerThread.mainLoop(Timer.java:552)</span><br><span class="line">    - locked &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)</span><br><span class="line">    at java.util.TimerThread.run(Timer.java:505)</span><br></pre></td></tr></table></figure><p>以上依次是：</p><ul><li><strong>“resin-22129” 线程名称：</strong>如果使用 java.lang.Thread 类生成一个线程的时候，线程名称为 Thread-(数字) 的形式，这里是resin生成的线程；</li><li><strong>daemon 线程类型：</strong>线程分为守护线程 (daemon) 和非守护线程 (non-daemon) 两种，通常都是守护线程；</li><li><strong>prio=10 线程优先级：</strong>默认为5，数字越大优先级越高；</li><li><strong>tid=0x00007fbe5c34e000 JVM线程的id：</strong>JVM内部线程的唯一标识，通过 java.lang.Thread.getId()获取，通常用自增的方式实现；</li><li><strong>nid=0x4cb1 系统线程id：</strong>对应的系统线程id（Native Thread ID)，可以通过 top 命令进行查看，线程id是十六进制的形式；</li><li><strong>waiting on condition 系统线程状态：</strong>这里是系统的线程状态，具体的含义见下面 系统线程状态 部分；</li><li><strong>[0x00007fbe4ff7c000] 起始栈地址：</strong>线程堆栈调用的其实内存地址；</li><li><strong>java.lang.Thread.State: WAITING (parking) JVM线程状态：</strong>这里标明了线程在代码级别的状态，详细的内容见下面的 JVM线程运行状态 部分。</li><li><strong>线程调用栈信息：</strong>下面就是当前线程调用的详细栈信息，用于代码的分析。堆栈信息应该从下向上解读，因为程序调用的顺序是从下向上的。</li></ul><h2 id="系统线程状态-Native-Thread-Status"><a href="#系统线程状态-Native-Thread-Status" class="headerlink" title="系统线程状态 (Native Thread Status)"></a>系统线程状态 (Native Thread Status)</h2><p>系统线程有如下状态：</p><h3 id="deadlock"><a href="#deadlock" class="headerlink" title="deadlock"></a>deadlock</h3><p>死锁线程，一般指多个线程调用期间进入了相互资源占用，导致一直等待无法释放的情况。</p><h3 id="runnable"><a href="#runnable" class="headerlink" title="runnable"></a>runnable</h3><p>一般指该线程正在执行状态中，该线程占用了资源，正在处理某个操作，如通过SQL语句查询数据库、对某个文件进行写入等。</p><h3 id="blocked"><a href="#blocked" class="headerlink" title="blocked"></a>blocked</h3><p>线程正处于阻塞状态，指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。</p><h3 id="waiting-on-condition"><a href="#waiting-on-condition" class="headerlink" title="waiting on condition"></a>waiting on condition</h3><p>线程正处于等待资源或等待某个条件的发生，具体的原因需要结合下面堆栈信息进行分析。</p><p>（1）如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某种资源且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取，或者正在等待其他线程的执行等。</p><p>（2）如果发现有大量的线程都正处于这种状态，并且堆栈信息中得知正等待网络读写，这是因为网络阻塞导致线程无法执行，很有可能是一个网络瓶颈的征兆：</p><p>网络非常繁忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；<br>网络可能是空闲的，但由于路由或防火墙等原因，导致包无法正常到达；<br>所以一定要结合系统的一些性能观察工具进行综合分析，比如netstat统计单位时间的发送包的数量，看是否很明显超过了所在网络带宽的限制；观察CPU的利用率，看系统态的CPU时间是否明显大于用户态的CPU时间。这些都指向由于网络带宽所限导致的网络瓶颈。</p><p>（3）还有一种常见的情况是该线程在 sleep，等待 sleep 的时间到了，将被唤醒。</p><h3 id="waiting-for-monitor-entry-或-in-Object-wait"><a href="#waiting-for-monitor-entry-或-in-Object-wait" class="headerlink" title="waiting for monitor entry 或 in Object.wait()"></a>waiting for monitor entry 或 in Object.wait()</h3><p>Moniter 是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者class的锁，每个对象都有，也仅有一个 Monitor。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/java-monitor.png" alt=""></p><p>从上图可以看出，每个Monitor在某个时刻只能被一个线程拥有，该线程就是 “Active Thread”，而其他线程都是 “Waiting Thread”，分别在两个队列 “Entry Set”和”Waint Set”里面等待。其中在 “Entry Set” 中等待的线程状态是 <strong>waiting for monitor entry</strong>，在 “Wait Set” 中等待的线程状态是 <strong>in Object.wait()</strong> 。</p><h4 id="（1）”Entry-Set”里面的线程。"><a href="#（1）”Entry-Set”里面的线程。" class="headerlink" title="（1）”Entry Set”里面的线程。"></a>（1）”Entry Set”里面的线程。</h4><p>我们称被 synchronized 保护起来的代码段为临界区，对应的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程申请进入临界区时，它就进入了 “Entry Set” 队列中，这时候有两种可能性：</p><ol><li>该Monitor不被其他线程拥有，”Entry Set”里面也没有其他等待的线程。本线程即成为相应类或者对象的Monitor的Owner，执行临界区里面的代码；此时在Thread Dump中显示线程处于 “Runnable” 状态。</li><li>该Monitor被其他线程拥有，本线程在 “Entry Set” 队列中等待。此时在Thread Dump中显示线程处于 “waiting for monity entry” 状态。</li></ol><p>临界区的设置是为了保证其内部的代码执行的原子性和完整性，但因为临界区在任何时间只允许线程串行通过，这和我们使用多线程的初衷是相反的。如果在多线程程序中大量使用synchronized，或者不适当的使用它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在Thread Dump中发现这个情况，应该审视源码并对其进行改进。</p><h4 id="（2）”Wait-Set”里面的线程"><a href="#（2）”Wait-Set”里面的线程" class="headerlink" title="（2）”Wait Set”里面的线程"></a>（2）”Wait Set”里面的线程</h4><p>当线程获得了Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（通常是被synchronized的对象）的wait()方法，放弃Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify()或者notifyAll()方法，”Wait Set”队列中的线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。”Wait Set”中的线程在Thread Dump中显示的状态为 in Object.wait()。通常来说，</p><p>通常来说，当CPU很忙的时候关注 Runnable 状态的线程，反之则关注 waiting for monitor entry 状态的线程。</p><h2 id="JVM线程运行状态-JVM-Thread-Status"><a href="#JVM线程运行状态-JVM-Thread-Status" class="headerlink" title="JVM线程运行状态 (JVM Thread Status)"></a>JVM线程运行状态 (JVM Thread Status)</h2><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-state-diagram.png" alt=""></p><p>在 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">java.lang.Thread.State</a> 中定义了线程的状态：</p><p>详细如下：<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ftnm3dmli7j30w20mf7bd.jpg" alt=""></p><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>至今尚未启动的线程的状态。线程刚被创建，但尚未启动。</p><h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>可运行线程的线程状态。线程正在JVM中执行，有可能在等待操作系统中的其他资源，比如处理器。</p><h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>受阻塞并且正在等待监视器的某一线程的线程状态。处于受阻塞状态的某一线程正在等待监视器锁，以便进入一个同步的块/方法，或者在调用 Object.wait 之后再次进入同步的块/方法。<br>在Thread Dump日志中通常显示为 java.lang.Thread.State: BLOCKED (on object monitor) 。</p><h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>某一等待线程的线程状态。线程正在无期限地等待另一个线程来执行某一个特定的操作，线程因为调用下面的方法之一而处于等待状态：</p><ul><li>不带超时的 Object.wait 方法，日志中显示为 java.lang.Thread.State: WAITING (on object monitor)</li><li>不带超时的 Thread.join 方法</li><li>LockSupport.park 方法，日志中显示为 java.lang.Thread.State: WAITING (parking)</li></ul><h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>指定了等待时间的某一等待线程的线程状态。线程正在等待另一个线程来执行某一个特定的操作，并设定了指定等待的时间，线程因为调用下面的方法之一而处于定时等待状态：</p><ul><li>Thread.sleep 方法</li><li>指定超时值的 Object.wait 方法</li><li>指定超时值的 Thread.join 方法</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>线程处于终止状态。</p><p>根据Java Doc中的说明，在给定的时间上，一个只能处于上述的一种状态之中，并且这些状态都是JVM的状态，跟操作系统中的线程状态无关。</p><h2 id="线程状态样例"><a href="#线程状态样例" class="headerlink" title="线程状态样例"></a>线程状态样例</h2><h3 id="等待状态样例"><a href="#等待状态样例" class="headerlink" title="等待状态样例"></a>等待状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-waiting-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;IoWaitThread&quot; prio=6 tid=0x0000000007334800 nid=0x2b3c waiting on condition [0x000000000893f000]</span><br><span class="line">  java.lang.Thread.State: WAITING (parking)</span><br><span class="line">               at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">               - parking to wait for  &lt;0x00000007d5c45850&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">               at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)</span><br><span class="line">               at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)</span><br><span class="line">               at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:440)</span><br><span class="line">               at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:629)</span><br><span class="line">               at com.nbp.theplatform.threaddump.ThreadIoWaitState$IoWaitHandler2.run(ThreadIoWaitState.java:89)</span><br><span class="line">               at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>上面例子中，IoWaitThread 线程保持等待状态并从 LinkedBlockingQueue 接收消息，如果 LinkedBlockingQueue 一直没有消息，该线程的状态将不会改变。</p><h3 id="阻塞状态样例"><a href="#阻塞状态样例" class="headerlink" title="阻塞状态样例"></a>阻塞状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-blocked-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&quot;BLOCKED_TEST pool-1-thread-1&quot; prio=6 tid=0x0000000006904800 nid=0x28f4 runnable [0x000000000785f000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">                at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">                at java.io.FileOutputStream.write(FileOutputStream.java:282)</span><br><span class="line">                at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)</span><br><span class="line">                at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:123)</span><br><span class="line">                - locked &lt;0x0000000780a31778&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">                at java.io.PrintStream.write(PrintStream.java:432)</span><br><span class="line">                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)</span><br><span class="line">                at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:202)</span><br><span class="line">                at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:272)</span><br><span class="line">                at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:85)</span><br><span class="line">                - locked &lt;0x0000000780a040c0&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">                at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:168)</span><br><span class="line">                at java.io.PrintStream.newLine(PrintStream.java:496)</span><br><span class="line">                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)</span><br><span class="line">                at java.io.PrintStream.println(PrintStream.java:687)</span><br><span class="line">                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:44)</span><br><span class="line">                - locked &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState$1.run(ThreadBlockedState.java:7)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - &lt;0x0000000780a31758&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">&quot;BLOCKED_TEST pool-1-thread-2&quot; prio=6 tid=0x0000000007673800 nid=0x260c waiting for monitor entry [0x0000000008abf000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:43)</span><br><span class="line">                - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState$2.run(ThreadBlockedState.java:26)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - &lt;0x0000000780b0c6a0&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">&quot;BLOCKED_TEST pool-1-thread-3&quot; prio=6 tid=0x00000000074f5800 nid=0x1994 waiting for monitor entry [0x0000000008bbf000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:42)</span><br><span class="line">                - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState$3.run(ThreadBlockedState.java:34)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - &lt;0x0000000780b0e1b8&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br></pre></td></tr></table></figure><p>在上面的例子中，BLOCKED_TEST pool-1-thread-1 线程占用了 <0x0000000780a000b0> 锁，然而 BLOCKED_TEST pool-1-thread-2 和 BLOCKED_TEST pool-1-thread-3 threads 正在等待获取锁。</0x0000000780a000b0></p><h3 id="死锁状态样例"><a href="#死锁状态样例" class="headerlink" title="死锁状态样例"></a>死锁状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-deadlock-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&quot;DEADLOCK_TEST-1&quot; daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting for monitor entry [0x000000000805f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)</span><br><span class="line">                - waiting to lock &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)</span><br><span class="line">                - locked &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - None</span><br><span class="line"></span><br><span class="line">&quot;DEADLOCK_TEST-2&quot; daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting for monitor entry [0x000000000815f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)</span><br><span class="line">                - waiting to lock &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)</span><br><span class="line">                - locked &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - None</span><br><span class="line"></span><br><span class="line">&quot;DEADLOCK_TEST-3&quot; daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting for monitor entry [0x000000000825f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)</span><br><span class="line">                - waiting to lock &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)</span><br><span class="line">                - locked &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - None</span><br></pre></td></tr></table></figure><p>上面的例子中，当线程 A 需要获取线程 B 的锁来继续它的任务，然而线程 B 也需要获取线程 A 的锁来继续它的任务的时候发生的。在 thread dump 中，你能看到 DEADLOCK_TEST-1 线程持有 0x00000007d58f5e48 锁，并且尝试获取 0x00000007d58f5e60 锁。你也能看到 DEADLOCK_TEST-2 线程持有 0x00000007d58f5e60，并且尝试获取 0x00000007d58f5e78，同时 DEADLOCK_TEST-3 线程持有 0x00000007d58f5e78，并且在尝试获取 0x00000007d58f5e48 锁，如你所见，每个线程都在等待获取另外一个线程的锁，这状态将不会被改变直到一个线程丢弃了它的锁。</p><h3 id="无限等待的Runnable状态样例"><a href="#无限等待的Runnable状态样例" class="headerlink" title="无限等待的Runnable状态样例"></a>无限等待的Runnable状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-runnable-waiting-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;socketReadThread&quot; prio=6 tid=0x0000000006a0d800 nid=0x1b40 runnable [0x00000000089ef000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">                at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">                at java.net.SocketInputStream.read(SocketInputStream.java:129)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)</span><br><span class="line">                - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.read0(StreamDecoder.java:107)</span><br><span class="line">                - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:93)</span><br><span class="line">                at java.io.InputStreamReader.read(InputStreamReader.java:151)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadSocketReadState$1.run(ThreadSocketReadState.java:27)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>上例中线程的状态是RUNNABLE，但在下面的堆栈日志中发现socketReadThread 线程正在无限等待读取 socket，因此不能单纯通过线程的状态来确定线程是否处于阻塞状态，应该根据详细的堆栈信息进行分析。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://www.theserverside.com/discussions/thread/61915.html" target="_blank" rel="noopener">100% CPU diagnosis</a><br><a href="http://blog.csdn.net/yanghongchang_/article/details/42004883" target="_blank" rel="noopener">JVM调优总结 + jstat 分析</a><br><a href="http://blog.csdn.net/wuzhilon88/article/details/49201891" target="_blank" rel="noopener">JVM调优总结(这个总结得比较全面)</a><br><a href="http://pengjiaheng.iteye.com/blog/search?query=JVM%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">JVM调优总结系列文章</a><br><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2036387.html" target="_blank" rel="noopener">JVM系列一：JVM内存组成及分配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/20/12131956.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面&lt;a href=&quot;https://yefan813.github.io/2018/07/25/jstack2/&quot;&gt;文章&lt;/a&gt;中只分析了Thread Dump日志文件的结构，今天针对日志文件中 Java EE middleware, third party &amp;amp; custom application Threads 部分线程的状态进行详细的分析。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java 内存 jstack thread dump 内存泄露" scheme="https://yefan813.github.io/tags/java-%E5%86%85%E5%AD%98-jstack-thread-dump-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之四：jstat命令的使用及VM Thread分析</title>
    <link href="https://yefan813.github.io/2018/07/26/jstat-command/"/>
    <id>https://yefan813.github.io/2018/07/26/jstat-command/</id>
    <published>2018-07-25T17:10:07.000Z</published>
    <updated>2018-08-31T07:24:07.012Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/25/36441958.html" target="_blank" rel="noopener">传送门</a></p><p>前面提到了一个使用jstack的shell脚本，通过命令可以很快地定位到指定线程对应的堆栈信息。</p><h2 id="使用jstat命令"><a href="#使用jstat命令" class="headerlink" title="使用jstat命令"></a>使用jstat命令</h2><p>当服务器CPU100%的时候，通过定位占用资源最大的线程定位到 VM Thread：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Thread&quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable</span><br></pre></td></tr></table></figure><a id="more"></a><p>这个时候需要使用 jstat -gc <pid> <period> <times> 命令查看gc的信息，显示结果如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/jstat-gc-result-1.jpg" alt=""></times></period></pid></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU      OC         OU       PC        PU       YGC     YGCT    FGC   FGCT       GCT</span><br><span class="line">64.0   64.0   0.0    0.0   332992.0   0.0    666304.0   73192.5   83968.0   83967.9   6893   17.576  6882   2705.923  2723.499</span><br></pre></td></tr></table></figure><p>结果中每个项目的含义可以参考官方对<a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html" target="_blank" rel="noopener">jstat</a>的文档，简单翻译如下：</p><ul><li>S0C: Young Generation第一个survivor space的内存大小 (kB).</li><li>S1C: Young Generation第二个survivor space的内存大小 (kB).</li><li>S0U: Young Generation第一个Survivor space当前已使用的内存大小 (kB).</li><li>S1U: Young Generation第二个Survivor space当前已经使用的内存大小 (kB).</li><li>EC: Young Generation中eden space的内存大小 (kB).</li><li>EU: Young Generation中Eden space当前已使用的内存大小 (kB).</li><li>OC: Old Generation的内存大小 (kB).</li><li>OU: Old Generation当前已使用的内存大小 (kB).</li><li>PC: Permanent Generation的内存大小 (kB)</li><li>PU: Permanent Generation当前已使用的内存大小 (kB).</li><li>YGC: 从启动到采样时Young Generation GC的次数</li><li>YGCT: 从启动到采样时Young Generation GC所用的时间 (s).</li><li>FGC: 从启动到采样时Old Generation GC的次数.</li><li>FGCT: 从启动到采样时Old Generation GC所用的时间 (s).</li><li>GCT: 从启动到采样时GC所用的总时间 (s).</li></ul><p>JDK8的结果稍微有所不同，结果含义可以参考：<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html。" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html。</a></p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>上面中的Young Generation、Permanent Generation和Old Generation等概念有一些混乱，这里简要的进行说明。简单来说，JVM内存由堆（Heap）和非堆（Non-heap）内存组成，前者共运行在JVM之上的程序使用，后者供JVM自己使用。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/r_sun-jdk-memory-area1.png" alt=""></p><p>堆内存的组成如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/r_heap1.png" alt=""></p><p>非堆内存由 Permanent Generation 和 Code Cache 两部分组成：</p><ul><li>Permanent Generation（持久代）: 保存虚拟机自己的静态(refective)数据，主要存放加载的Class类级别静态对象如class本身，method，field等等。permanent generation空间不足会引发full GC；</li><li>Code Cache: 用于编译和保存本地代码（native code）的内存，JVM内部处理或优化。</li></ul><h2 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h2><h3 id="堆内存设置"><a href="#堆内存设置" class="headerlink" title="堆内存设置"></a>堆内存设置</h3><ul><li>堆内存（总的）由 -Xms 和 -Xmx 分别设置最小和最大堆内存</li><li>New Generation 由 -Xmn 设置，-XX:SurvivorRatio=m 设置 Eden和 两个Survivor区的大小比值；-XX:NewRatio=n 设置 New Generation 和 Old Generation 的大小比值。</li><li>每个线程的堆栈大小由 ·-Xss· 设置，JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li></ul><h3 id="非堆内存设置"><a href="#非堆内存设置" class="headerlink" title="非堆内存设置"></a>非堆内存设置</h3><p>非堆内存由 -XX:PermSize=n 和 -XX:MaxPermSize=n 分别设置最小和最大非堆内存大小</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>介绍完上面的概念之后，我们再来看最上面的日志信息，有两个地方有问题：<br>一是FGC（完全GC）的数量太大了，正常来说FGC应该占整个GC（YGC+FGC）的1%到5%才正常，上面日志上完全GC的次数太多了；二是日志中PU的值太大了，基本上已经达到设置的PC了，因此需要增大MaxPermSize的值。<br>不过这只是权宜之计，出现这么大的非堆内存，肯定什么地方出现了问题，还需要进一步找到占用内存的原因，这也是后面文章所要说的。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://just2do.iteye.com/blog/2275894" target="_blank" rel="noopener">性能分析之– JAVA Thread Dump 分析综述</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">三个实例演示 Java Thread Dump 日志分析</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/03/18/tda.html" target="_blank" rel="noopener">各种 Java Thread State 第一分析法则</a><br><a href="https://dzone.com/articles/how-analyze-java-thread-dumps" target="_blank" rel="noopener">How to Analyze Java Thread Dumps | 中文版</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html" target="_blank" rel="noopener">官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/25/36441958.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面提到了一个使用jstack的shell脚本，通过命令可以很快地定位到指定线程对应的堆栈信息。&lt;/p&gt;
&lt;h2 id=&quot;使用jstat命令&quot;&gt;&lt;a href=&quot;#使用jstat命令&quot; class=&quot;headerlink&quot; title=&quot;使用jstat命令&quot;&gt;&lt;/a&gt;使用jstat命令&lt;/h2&gt;&lt;p&gt;当服务器CPU100%的时候，通过定位占用资源最大的线程定位到 VM Thread：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;VM Thread&amp;quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="java 内存 jstat JVM" scheme="https://yefan813.github.io/tags/java-%E5%86%85%E5%AD%98-jstat-JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之二：jstack生成的Thread Dump日志结构解析</title>
    <link href="https://yefan813.github.io/2018/07/25/jstack2/"/>
    <id>https://yefan813.github.io/2018/07/25/jstack2/</id>
    <published>2018-07-25T15:29:47.000Z</published>
    <updated>2018-08-31T07:24:48.741Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/19/51301886.html" target="_blank" rel="noopener">传送门</a></p><p>这篇文章首先对Thread Dump日志文件的结构进行分析<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftmj21ohk3j31ie15iwp4.jpg" alt=""></p><p>一个典型的thread dump文件主要由一下几个部分组成：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/Thread_Dump_view_HotSpot_VM.png" alt=""><br>上图将JVM上的线程堆栈信息和线程信息做了详细的拆解</p><h2 id="第一部分：Full-thread-dump-identifier"><a href="#第一部分：Full-thread-dump-identifier" class="headerlink" title="第一部分：Full thread dump identifier"></a>第一部分：Full thread dump identifier</h2><p>这一部分是内容最开始的部分，展示了快照文件的生成时间和JVM的版本信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.151-b12 mixed mode):</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="第二部分：Java-EE-middleware-third-party-amp-custom-application-Threads"><a href="#第二部分：Java-EE-middleware-third-party-amp-custom-application-Threads" class="headerlink" title="第二部分：Java EE middleware, third party &amp; custom application Threads"></a>第二部分：Java EE middleware, third party &amp; custom application Threads</h2><p>这是整个文件的核心部分，里面展示了JavaEE容器（如tomcat、resin等）、自己的程序中所使用的线程信息<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ftml24zk3hj31ic0jsaek.jpg" alt=""></p><h2 id="第三部分：HotSpot-VM-Thread"><a href="#第三部分：HotSpot-VM-Thread" class="headerlink" title="第三部分：HotSpot VM Thread"></a>第三部分：HotSpot VM Thread</h2><p>这一部分展示了JVM内部线程的信息，用于执行内部的原生操作。下面常见的几种内置线程：</p><h3 id="“Attach-Listener”"><a href="#“Attach-Listener”" class="headerlink" title="“Attach Listener”"></a>“Attach Listener”</h3><p>该线程负责接收外部命令，执行该命令并把结果返回给调用者，此种类型的线程通常在桌面程序中出现<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ftml3adrl8j31ec05wmxy.jpg" alt=""></p><h3 id="“DestroyJavaVM”"><a href="#“DestroyJavaVM”" class="headerlink" title="“DestroyJavaVM”"></a>“DestroyJavaVM”</h3><p>执行main()的线程在执行完之后调用JNI中的 jni_DestroyJavaVM() 方法会唤起DestroyJavaVM 线程。在JBoss启动之后，也会唤起DestroyJavaVM线程，处于等待状态，等待其它线程（java线程和native线程）退出时通知它卸载JVM。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;DestroyJavaVM&quot; #43 prio=5 os_prio=31 tid=0x00007fd9c8286000 nid=0x1b03 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“Service-Thread”"><a href="#“Service-Thread”" class="headerlink" title="“Service Thread”"></a>“Service Thread”</h3><p>用于启动服务的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Service Thread&quot; #9 daemon prio=9 os_prio=31 tid=0x00007fd9c684c000 nid=0x5203 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“CompilerThread”"><a href="#“CompilerThread”" class="headerlink" title="“CompilerThread”"></a>“CompilerThread”</h3><p>用来调用JITing，实时编译装卸CLASS。通常JVM会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，比如CompilerThread1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;C2 CompilerThread1&quot; daemon prio=10 tid=0x00007fbea814b000 nid=0x5f1 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; daemon prio=10 tid=0x00007fbea8142000 nid=0x5f0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“Signal-Dispatcher”"><a href="#“Signal-Dispatcher”" class="headerlink" title="“Signal Dispatcher”"></a>“Signal Dispatcher”</h3><p>Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。<br>signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Signal Dispatcher&quot; daemon prio=10 tid=0x00007fbea81bf800 nid=0x5ef runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><h3 id="“Finalizer”"><a href="#“Finalizer”" class="headerlink" title="“Finalizer”"></a>“Finalizer”</h3><p>这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：</p><ol><li><p>只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；<br>该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；</p></li><li><p>JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；</p></li><li>JVM为什么要单独用一个线程来执行finalize()方法呢？<br>如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Finalizer&quot; daemon prio=10 tid=0x00007fbea80da000 nid=0x5eb in Object.wait() [0x00007fbeac044000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)</span><br><span class="line">    - locked &lt;0x00000006d173c1a8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)</span><br><span class="line">    at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br></pre></td></tr></table></figure><h3 id="“Reference-Handler”"><a href="#“Reference-Handler”" class="headerlink" title="“Reference Handler”"></a>“Reference Handler”</h3><p>JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Reference Handler&quot; daemon prio=10 tid=0x00007fbea80d8000 nid=0x5ea in Object.wait() [0x00007fbeac085000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    at java.lang.Object.wait(Object.java:503)</span><br><span class="line">    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)</span><br><span class="line">    - locked &lt;0x00000006d173c1f0&gt; (a java.lang.ref.Reference$Lock)</span><br></pre></td></tr></table></figure><h3 id="“VM-Thread”"><a href="#“VM-Thread”" class="headerlink" title="“VM Thread”"></a>“VM Thread”</h3><p>JVM中线程的母体，根据HotSpot源码中关于vmThread.hpp里面的注释，它是一个单例的对象（最原始的线程）会产生或触发所有其他的线程，这个单例的VM线程是会被其他线程所使用来做一些VM操作（如清扫垃圾等）。<br>在 VM Thread 的结构体里有一个VMOperationQueue列队，所有的VM线程操作(vm_operation)都会被保存到这个列队当中，VMThread 本身就是一个线程，它的线程负责执行一个自轮询的loop函数(具体可以参考：VMThread.cpp里面的void VMThread::loop()) ，该loop函数从VMOperationQueue列队中按照优先级取出当前需要执行的操作对象(VM_Operation)，并且调用VM_Operation-&gt;evaluate函数去执行该操作类型本身的业务逻辑。<br>VM操作类型被定义在vm_operations.hpp文件内，列举几个：ThreadStop、ThreadDump、PrintThreads、GenCollectFull、GenCollectFullConcurrent、CMS_Initial_Mark、CMS_Final_Remark….. 有兴趣的同学，可以自己去查看源文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Thread&quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable</span><br></pre></td></tr></table></figure><h2 id="第四部分：HotSpot-GC-Thread"><a href="#第四部分：HotSpot-GC-Thread" class="headerlink" title="第四部分：HotSpot GC Thread"></a>第四部分：HotSpot GC Thread</h2><p>JVM中用于进行资源回收的线程，包括以下几种类型的线程：</p><h3 id="“VM-Periodic-Task-Thread”"><a href="#“VM-Periodic-Task-Thread”" class="headerlink" title="“VM Periodic Task Thread”"></a>“VM Periodic Task Thread”</h3><p>该线程是JVM周期性任务调度的线程，它由WatcherThread创建，是一个单例对象。该线程在JVM内使用得比较频繁，比如：定期的内存监控、JVM运行状况监控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Periodic Task Thread&quot; prio=10 tid=0x00007fbea82ae800 nid=0x5fa waiting on condition</span><br></pre></td></tr></table></figure><p>可以使用jstat 命令查看GC的情况，比如查看某个进程没有存活必要的引用可以使用命令 jstat -gcutil <pid> 250 7 参数中pid是进程id，后面的250和7表示每250毫秒打印一次，总共打印7次。<br>这对于防止因为应用代码中直接使用native库或者第三方的一些监控工具的内存泄漏有非常大的帮助。</pid></p><h3 id="“GC-task-thread-0-ParallelGC-”"><a href="#“GC-task-thread-0-ParallelGC-”" class="headerlink" title="“GC task thread#0 (ParallelGC)”"></a>“GC task thread#0 (ParallelGC)”</h3><p>垃圾回收线程，该线程会负责进行垃圾回收。通常JVM会启动多个线程来处理这个工作，线程名称中#后面的数字也会累加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; prio=5 tid=0x00007fc6b480d000 nid=0x2503 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; prio=5 tid=0x00007fc6b2812000 nid=0x2703 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; prio=5 tid=0x00007fc6b2812800 nid=0x2903 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; prio=5 tid=0x00007fc6b2813000 nid=0x2b03 runnable</span><br></pre></td></tr></table></figure><p>如果在JVM中增加了 -XX:+UseConcMarkSweepGC 参数将会启用CMS （Concurrent Mark-Sweep）GC Thread方式，以下是该模式下的线程类型：</p><h3 id="“Gang-worker-0-Parallel-GC-Threads-”"><a href="#“Gang-worker-0-Parallel-GC-Threads-”" class="headerlink" title="“Gang worker#0 (Parallel GC Threads)”"></a>“Gang worker#0 (Parallel GC Threads)”</h3><p>原来垃圾回收线程GC task thread#0 (ParallelGC) 被替换为 Gang worker#0 (Parallel GC Threads)。Gang worker 是JVM用于年轻代垃圾回收(minor gc)的线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Gang worker#0 (Parallel GC Threads)&quot; prio=10 tid=0x00007fbea801b800 nid=0x5e4 runnable </span><br><span class="line"></span><br><span class="line">&quot;Gang worker#1 (Parallel GC Threads)&quot; prio=10 tid=0x00007fbea801d800 nid=0x5e7 runnable </span><br><span class="line">&quot;Concurrent Mark-Sweep GC Thread&quot;</span><br></pre></td></tr></table></figure><p>并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于年老代垃圾回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Concurrent Mark-Sweep GC Thread&quot; prio=10 tid=0x00007fbea8073800 nid=0x5e8 runnable </span><br><span class="line">&quot;Surrogate Locker Thread (Concurrent GC)&quot;</span><br></pre></td></tr></table></figure><p>此线程主要配合CMS垃圾回收器来使用，是一个守护线程，主要负责处理GC过程中Java层的Reference（指软引用、弱引用等等）与jvm 内部层面的对象状态同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Surrogate Locker Thread (Concurrent GC)&quot; daemon prio=10 tid=0x00007fbea8158800 nid=0x5ee waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><p>这里以 WeakHashMap 为例进行说明，首先是一个关键点：</p><ul><li>WeakHashMap和HashMap一样，内部有一个Entry[]数组;</li><li>WeakHashMap的Entry比较特殊，它的继承体系结构为Entry-&gt;WeakReference-&gt;Reference;</li><li>Reference 里面有一个全局锁对象：Lock，它也被称为pending_lock，注意：它是静态对象；</li><li>Reference 里面有一个静态变量：pending；</li><li>Reference 里面有一个静态内部类：ReferenceHandler的线程，它在static块里面被初始化并且启动，启动完成后处于wait状态，它在一个Lock同步锁模块中等待；</li><li>WeakHashMap里面还实例化了一个ReferenceQueue列队</li></ul><p>假设，WeakHashMap对象里面已经保存了很多对象的引用，JVM 在进行CMS GC的时候会创建一个ConcurrentMarkSweepThread（简称CMST）线程去进行GC。ConcurrentMarkSweepThread线程被创建的同时会创建一个SurrogateLockerThread（简称SLT）线程并且启动它，SLT启动之后，处于等待阶段。<br>CMST开始GC时，会发一个消息给SLT让它去获取Java层Reference对象的全局锁：Lock。直到CMS GC完毕之后，JVM 会将WeakHashMap中所有被回收的对象所属的WeakReference容器对象放入到Reference 的pending属性当中（每次GC完毕之后，pending属性基本上都不会为null了），然后通知SLT释放并且notify全局锁:Lock。此时激活了ReferenceHandler线程的run方法，使其脱离wait状态，开始工作了。<br>ReferenceHandler这个线程会将pending中的所有WeakReference对象都移动到它们各自的列队当中，比如当前这个WeakReference属于某个WeakHashMap对象，那么它就会被放入相应的ReferenceQueue列队里面（该列队是链表结构）。 当我们下次从WeakHashMap对象里面get、put数据或者调用size方法的时候，WeakHashMap就会将ReferenceQueue列队中的WeakReference依依poll出来去和Entry[]数据做比较，如果发现相同的，则说明这个Entry所保存的对象已经被GC掉了，那么将Entry[]内的Entry对象剔除掉</p><h2 id="第五部分：JNI-global-references-count"><a href="#第五部分：JNI-global-references-count" class="headerlink" title="第五部分：JNI global references count"></a>第五部分：JNI global references count</h2><p>这一部分主要回收那些在native代码上被引用，但在java代码中却没有存活必要的引用，对于防止因为应用代码中直接使用native库或第三方的一些监控工具的内存泄漏有非常大的帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNI global references: 830</span><br></pre></td></tr></table></figure><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://www.javacodegeeks.com/2012/03/jvm-how-to-analyze-thread-dump.html" target="_blank" rel="noopener">JVM: How to analyze Thread Dump | 中文版</a><br><a href="http://maping930883.blogspot.com/2014/04/java010jvm.html" target="_blank" rel="noopener">Java_010：JVM内部线程功能说明（摘录+整理）</a><br><a href="http://javaeesupportpatterns.blogspot.com/2012/07/how-to-analyze-thread-dump-part-5.html" target="_blank" rel="noopener">How to analyze Thread Dump – Part 5: Thread Stack Trace</a><br><a href="http://go-on.iteye.com/blog/1673894" target="_blank" rel="noopener">虚拟机stack全分析</a><br><a href="http://blog.csdn.net/zlzlei/article/details/46471627" target="_blank" rel="noopener">Linux使用jstat命令查看jvm的GC情况</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/19/51301886.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章首先对Thread Dump日志文件的结构进行分析&lt;br&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftmj21ohk3j31ie15iwp4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个典型的thread dump文件主要由一下几个部分组成：&lt;br&gt;&lt;img src=&quot;https://www.javatang.com/wp-content/uploads/2017/10/Thread_Dump_view_HotSpot_VM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;上图将JVM上的线程堆栈信息和线程信息做了详细的拆解&lt;/p&gt;
&lt;h2 id=&quot;第一部分：Full-thread-dump-identifier&quot;&gt;&lt;a href=&quot;#第一部分：Full-thread-dump-identifier&quot; class=&quot;headerlink&quot; title=&quot;第一部分：Full thread dump identifier&quot;&gt;&lt;/a&gt;第一部分：Full thread dump identifier&lt;/h2&gt;&lt;p&gt;这一部分是内容最开始的部分，展示了快照文件的生成时间和JVM的版本信息。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.151-b12 mixed mode):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="java 内存 jstack thread dump 内存泄露" scheme="https://yefan813.github.io/tags/java-%E5%86%85%E5%AD%98-jstack-thread-dump-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之一：使用jstack定位线程堆栈信息</title>
    <link href="https://yefan813.github.io/2018/07/25/jstack%E4%BD%BF%E7%94%A8/"/>
    <id>https://yefan813.github.io/2018/07/25/jstack%E4%BD%BF%E7%94%A8/</id>
    <published>2018-07-25T08:36:19.000Z</published>
    <updated>2018-08-31T07:23:53.733Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://www.javatang.com/archives/2017/10/19/33151873.html" target="_blank" rel="noopener">这里</a></p><p>上线的系统升级之后，出现了严重的高CPU的问题</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在对Java内存泄漏进行分析的时候，需要对jvm运行期间的内存占用、线程执行等情况进行记录的dump文件，常用的主要有thread dump和heap dump。</p><blockquote><ul><li>thread dump 主要记录JVM在某一时刻各个线程执行的情况，以栈的形式显示，是一个文本文件。通过对thread dump文件可以分析出程序的问题出现在什么地方，从而定位具体的代码然后进行修正。thread dump需要结合占用系统资源的线程id进行分析才有意义。</li><li>heap dump 主要记录了在某一时刻JVM堆中对象使用的情况，即某个时刻JVM堆的快照，是一个二进制文件，主要用于分析哪些对象占用了太对的堆空间，从而发现导致内存泄漏的对象。</li></ul></blockquote><p>上面两种dump文件都具有实时性，因此需要在服务器出现问题的时候生成，并且多生成几个文件，方便进行对比分析。下面我们先来说一下如何生成 thread dump。</p><a id="more"></a><h2 id="使用jstack生成thread-dump"><a href="#使用jstack生成thread-dump" class="headerlink" title="使用jstack生成thread dump"></a>使用<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html" target="_blank" rel="noopener">jstack</a>生成thread dump</h2><p>当服务器出现高CPU的时候，首先执行 top -c 命令动态显示进程及占用资源的排行，如下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/top-result.png" alt=""><br>top后面的参数-c可以显示进程详细的信息。top命令执行的时候还可以执行一些快捷键：</p><blockquote><ul><li>1 对于多核服务器，可以显示各个CPU占用资源的情况</li><li>shift+h 显示所有的线程信息</li><li>shift+w 将当前 top 命令的设置保存到 ~/.toprc 文件中，这样不用每次都执行快捷键了</li></ul></blockquote><p>以上图为例，pid为1503的进程占用了大量的CPU资源，接下来需要将占用CPU最高进程中的”线程”打印出来，可以用 top -bn1 -H -p <pid> 命令，执行结果如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/top-threads.png" alt=""></pid></p><p>上面 -bn1 参数的含义是只输出一次结果，而不是显示一个动态的结果。</p><p>我个人请喜欢用 ps -mp <pid> -o THREAD,tid,time | sort -k2r 命令查看，后面的sort参数根据线程占用的cpu比例进行排序，结果如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/ps-mp-threads.png" alt=""><br>接下来我们清楚今天的主角 jstack，这是一个在JDK5开始提供的内置工具，可以打印指定进程中线程运行的状态，包括线程数量、是否存在死锁、资源竞争情况和线程的状态等等。有下面的几个常用的参数：</pid></p><ul><li>-l 长列表，打印关于锁的附加信息</li><li>-m 打印java和jni框架的所有栈信息</li></ul><p>因为thread id在栈信息中是以十六进制的形式显示的，因此需要使用 printf “%x \n” “tid” 命令将现场id转成十六进制的值，然后执行 jstack -l “pid” | grep “thread-hex-id” -A 10 命令显示出错的堆栈信息，如下图<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/jstack-thread-id-result.png" alt=""></p><p>上面命令中 -A 10 参数用来指定显示行数，否则只会显示一行信息。</p><p>这样通过上图，可以很快地定位到程序问题的代码，然后对代码进行分析和改进即可。<strong>注意：需要在多个时间段提出多个 Thread Dump信息，然后综合进行对比分析，单独分析一个文件是没有意义的。</strong></p><p>上面讲述了整个的分析过程，不过所有的命令就是实时的，所以最好创建一个shell脚本瞬间执行完成，下面对 <a href="https://www.jianshu.com/p/90579ec3113f" target="_blank" rel="noopener">当CPU飙高时，它在做什么</a> 这篇文章中所提供的shell进行了改进如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">if [ $# -ne 1 ]; then</span><br><span class="line">    echo &quot;usage: $0 &lt;pid&gt; [line-number]&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># java home</span><br><span class="line">if test -z $JAVA_HOME </span><br><span class="line">then</span><br><span class="line">    JAVA_HOME=&apos;/usr/local/jdk&apos;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#pid</span><br><span class="line">pid=$1</span><br><span class="line"># checking pid</span><br><span class="line">if test -z &quot;$($JAVA_HOME/bin/jps -l | cut -d &apos;&apos; -f 1 | grep $pid)&quot;</span><br><span class="line">then</span><br><span class="line">    echo &quot;process of $pid is not exists&quot;</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#line number</span><br><span class="line">if test -z $linenum</span><br><span class="line">then</span><br><span class="line">    linenum=10</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">stackfile=stack$pid.dump</span><br><span class="line">threadsfile=threads$pid.dump</span><br><span class="line"></span><br><span class="line"># generate java stack</span><br><span class="line">$JAVA_HOME/bin/jstack -l $pid &gt;&gt; $stackfile</span><br><span class="line">ps -mp $pid -o THREAD,tid,time | sort -k2r | awk &apos;&#123;if ($1 !=&quot;USER&quot; &amp;&amp; $2 != &quot;0.0&quot; &amp;&amp; $8 !=&quot;-&quot;) print $8;&#125;&apos; | xargs printf &quot;%x\n&quot; &gt;&gt; $threadsfile</span><br><span class="line">tids=&quot;$(cat $threadsfile)&quot;</span><br><span class="line">for tid in $tids</span><br><span class="line">do</span><br><span class="line">    echo &quot;------------------------------ ThreadId ($tid) ------------------------------&quot;</span><br><span class="line">    cat $stackfile | grep 0x$tid -A $linenum</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">rm -f $stackfile $threadsfile</span><br></pre></td></tr></table></figure><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://www.cnblogs.com/toSeeMyDream/p/7151635.html" target="_blank" rel="noopener">java程序性能分析之thread dump和heap dump</a><br><a href="http://www.cnblogs.com/chengJAVA/p/5821218.html" target="_blank" rel="noopener">JVM调优之jstack找出最耗cpu的线程并定位代码</a><br><a href="https://www.jianshu.com/p/90579ec3113f" target="_blank" rel="noopener">当CPU飙高时，它在做什么</a><br><a href="http://www.blogjava.net/ldwblog/archive/2016/12/22/432166.html" target="_blank" rel="noopener">JAVA应用CPU占用100%|内存泄漏分析总结</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html" target="_blank" rel="noopener">官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;https://www.javatang.com/archives/2017/10/19/33151873.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上线的系统升级之后，出现了严重的高CPU的问题&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;在对Java内存泄漏进行分析的时候，需要对jvm运行期间的内存占用、线程执行等情况进行记录的dump文件，常用的主要有thread dump和heap dump。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;thread dump 主要记录JVM在某一时刻各个线程执行的情况，以栈的形式显示，是一个文本文件。通过对thread dump文件可以分析出程序的问题出现在什么地方，从而定位具体的代码然后进行修正。thread dump需要结合占用系统资源的线程id进行分析才有意义。&lt;/li&gt;
&lt;li&gt;heap dump 主要记录了在某一时刻JVM堆中对象使用的情况，即某个时刻JVM堆的快照，是一个二进制文件，主要用于分析哪些对象占用了太对的堆空间，从而发现导致内存泄漏的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面两种dump文件都具有实时性，因此需要在服务器出现问题的时候生成，并且多生成几个文件，方便进行对比分析。下面我们先来说一下如何生成 thread dump。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jstack 内存 栈 JVM 线程 heap" scheme="https://yefan813.github.io/tags/jstack-%E5%86%85%E5%AD%98-%E6%A0%88-JVM-%E7%BA%BF%E7%A8%8B-heap/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之七：jmap + MAT 内存溢出</title>
    <link href="https://yefan813.github.io/2018/07/24/jmap-MAT-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>https://yefan813.github.io/2018/07/24/jmap-MAT-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2018-07-24T15:45:47.000Z</published>
    <updated>2018-08-31T07:23:45.654Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/11/08/11582145.html" target="_blank" rel="noopener">传送门</a></p><h3 id="手动构建堆内存溢出："><a href="#手动构建堆内存溢出：" class="headerlink" title="手动构建堆内存溢出："></a>手动构建堆内存溢出：</h3><p>使用 asm 构造 class，后面模拟非堆内存溢出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * https://blog.csdn.net/bolg_hero/article/details/78189621</span><br><span class="line"> * 继承ClassLoader是为了方便调用defineClass方法，因为该方法的定义为protected</span><br><span class="line"> * */</span><br><span class="line">public class Metaspace extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public static List&lt;Class&lt;?&gt;&gt; createClasses() &#123;</span><br><span class="line">        // 类持有</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        // 循环1000w次生成1000w个不同的类。</span><br><span class="line">        for (int i = 0; i &lt; 10000000; ++i) &#123;</span><br><span class="line">            ClassWriter cw = new ClassWriter(0);</span><br><span class="line">            // 定义一个类名称为Class&#123;i&#125;，它的访问域为public，父类为java.lang.Object，不实现任何接口</span><br><span class="line">            cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null,</span><br><span class="line">                    &quot;java/lang/Object&quot;, null);</span><br><span class="line">            // 定义构造函数&lt;init&gt;方法</span><br><span class="line">            MethodVisitor mw = cw.visitMethod(Opcodes.ACC_PUBLIC, &quot;&lt;init&gt;&quot;,</span><br><span class="line">                    &quot;()V&quot;, null, null);</span><br><span class="line">            // 第一个指令为加载this</span><br><span class="line">            mw.visitVarInsn(Opcodes.ALOAD, 0);</span><br><span class="line">            // 第二个指令为调用父类Object的构造函数</span><br><span class="line">            mw.visitMethodInsn(Opcodes.INVOKESPECIAL, &quot;java/lang/Object&quot;,</span><br><span class="line">                    &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">            // 第三条指令为return</span><br><span class="line">            mw.visitInsn(Opcodes.RETURN);</span><br><span class="line">            mw.visitMaxs(1, 1);</span><br><span class="line">            mw.visitEnd();</span><br><span class="line">            Metaspace test = new Metaspace();</span><br><span class="line">            byte[] code = cw.toByteArray();</span><br><span class="line">            // 定义类</span><br><span class="line">            Class&lt;?&gt; exampleClass = test.defineClass(&quot;Class&quot; + i, code, 0, code.length);</span><br><span class="line">            classes.add(exampleClass);</span><br><span class="line">        &#125;</span><br><span class="line">        return classes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>内存溢出使用的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 名称</span><br><span class="line">     */</span><br><span class="line">    private String name;</span><br><span class="line">    /**</span><br><span class="line">     * 年龄</span><br><span class="line">     */</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/&quot;)</span><br><span class="line">public class MemoryController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private List&lt;Class&lt;?&gt;&gt; clazzList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 记得设置启动参数 -Xmx16M -Xms16M</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/heap&quot;)</span><br><span class="line">    public String heap()&#123;</span><br><span class="line">        int i = 0 ;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            userList.add(new User(UUID.randomUUID().toString(), i++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 记得设置启动参数 -XX:MetaspaceSize=32M -XX:MaxMetaspaceSize=32M</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/nonHeap&quot;)</span><br><span class="line">    public String nonHeap()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            clazzList.addAll(Metaspace.createClasses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟堆内存溢出时设置启动参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx16M -Xms16M</span><br></pre></td></tr></table></figure><p>模拟非堆内存溢出时设置启动参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=32M </span><br><span class="line">-XX:MaxMetaspaceSize=32M</span><br></pre></td></tr></table></figure><p>内存溢出自动导出映像文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=./</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftlxgs9q5xj30qs04uq4d.jpg" alt=""></p><p>可以看到这里自动导出了堆内存快照</p><h3 id="还可以-jmap-手动导出快照"><a href="#还可以-jmap-手动导出快照" class="headerlink" title="还可以 jmap 手动导出快照"></a>还可以 jmap 手动导出快照</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftlxl6lctoj31100rcgqd.jpg" alt=""></p><p>使用说明：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html#CEGCECJB" target="_blank" rel="noopener">链接</a></p><p>使用方式：<br>1，jps 查看 java 进程<br><code>jps -l</code><br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftlxn9h6nbj30rs04s0ti.jpg" alt=""></p><p>2, jmap导出堆快照<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftlxptn6b9j30sa03e3yz.jpg" alt=""></p><h2 id="堆内存导出之后使用-MAT-分析内存溢出"><a href="#堆内存导出之后使用-MAT-分析内存溢出" class="headerlink" title="堆内存导出之后使用 MAT 分析内存溢出"></a>堆内存导出之后使用 MAT 分析内存溢出</h2><p>MAT 打开之后是这样<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftlyk4nfx3j31kw0sf11f.jpg" alt=""></p><p>MAT 分析结果<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftlynwu1qoj30oy0cq76m.jpg" alt=""></p><p>这里可以看到最大对象的相关信息<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftlytnxktvj30zr0n3dkv.jpg" alt=""></p><p>界面功能介绍：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftlz0ctbz8j30m30j27a5.jpg" alt=""></p><h3 id="这里需要介绍一下-Shallow-Heap-和-Retained-Heap概念"><a href="#这里需要介绍一下-Shallow-Heap-和-Retained-Heap概念" class="headerlink" title="这里需要介绍一下 Shallow Heap 和 Retained Heap概念"></a>这里需要介绍一下 Shallow Heap 和 Retained Heap概念</h3><p>Shallow Heap 和 Retained Heap</p><p>Shallow Heap表示对象本身占用内存的大小，不包含对其他对象的引用，也就是对象头加成员变量（不是成员变量的值）的总和。</p><p>Retained Heap是该对象自己的Shallow Heap，并加上从该对象能直接或间接访问到对象的Shallow Heap之和。换句话说，Retained Heap是该对象GC之后所能回收到内存的总和。</p><p>把内存中的对象看成下图中的节点，并且对象和对象之间互相引用。这里有一个特殊的节点GC Roots，这就是reference chain的起点。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/11/retained_objects.png" alt=""></p><p>从obj1入手，上图中蓝色节点代表仅仅只有通过obj1才能直接或间接访问的对象。因为可以通过GC Roots访问，所以左图的obj3不是蓝色节点；而在右图却是蓝色，因为它已经被包含在retained集合内。所以对于左图，obj1的retained size是obj1、obj2、obj4的shallow size总和；右图的retained size是obj1、obj2、obj3、obj4的shallow size总和。obj2的retained size可以通过相同的方式计算。</p><h4 id="对象引用（Reference）"><a href="#对象引用（Reference）" class="headerlink" title="对象引用（Reference）"></a>对象引用（Reference）</h4><p>对象引用按从最强到最弱有如下级别，不同的引用（可到达性）级别反映了对象的生命周期：</p><ol><li>强引用（Strong Ref）：通常我们编写的代码都是强引用，于此相对应的是强可达性，只有去掉强可达性，对象才能被回收。</li><li>软引用（Soft Ref）：对应软可达性，只要有足够的内存就一直保持对象，直到发现内存不足且没有强引用的时候才回收对象。</li><li>弱引用（Weak Ref）：比软引用更弱，当发现不存在强引用的时候会立即回收此类型的对象，而不需要等到内存不足。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。</li><li>虚引用（Phantom Ref）：根本不会在内存中保持该类型的对象，只能使用虚引用本身，一般用于在进入finalize()方法后进行特殊的清理过程，通过java.lang.ref.PhantomReference实现。</li></ol><h3 id="GC-Roots和Reference-Chain"><a href="#GC-Roots和Reference-Chain" class="headerlink" title="GC Roots和Reference Chain"></a>GC Roots和Reference Chain</h3><p>JVM在进行GC的时候是通过使用可达性来判断对象是否存活，通过GC Roots（GC根节点）的对象作为起始点，从这些节点开始进行向下搜索，搜索所走过的路径成为Reference Chain（引用链），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>如下图所示，对象object 5、object 6、object 7虽然互相有关联，它们的引用并不为0，但是它们到GC Roots是不可达的，因此它们将会被判定为是可回收的对象。<br><img src="https://www.javatang.com/wp-content/uploads/2017/11/gc-roots.jpg" alt=""></p><h3 id="Histogram（直方图）视图"><a href="#Histogram（直方图）视图" class="headerlink" title="Histogram（直方图）视图"></a>Histogram（直方图）视图</h3><p>点击工具栏上的<img src="https://www.javatang.com/wp-content/uploads/2017/10/fe892b246b43fa64b866790a2f256859.png" alt="">图标可以打开Histogram（直方图）视图，可以列出每个类产生的实例数量，以及所占用的内存大小和百分比。主界面如下图所示：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftlzb7iod1j30tj0mwn36.jpg" alt=""></p><p>图中Shallow Heap 和 Retained Heap分别表示对象自身不包含引用的大小和对象自身并包含引用的大小，具体请参考下面 Shallow Heap 和 Retained Heap 部分的内容。默认的大小单位是 Bytes，可以在 Window - Preferences 菜单中设置单位。</p><p>通过直方图视图可以很容易找到占用内存最多的几个类（通过Retained Heap排序），还可以通过其他方式进行分组（见下图）。<br><img src="https://www.javatang.com/wp-content/uploads/2017/11/332724b74c697a72e19c94cf4188bee2.png" alt=""><br>如果存在内存溢出，时间久了溢出类的实例数量或者内存占比会越来越多，排名也越来越靠前。可以点击工具类上的<img src="https://www.javatang.com/wp-content/uploads/2017/11/b0f463b6011fdfb7cc6c7b0826ac97e5.png" alt="">图标进行对比，通过多次对比不同时间点下的直方图对比就很容易把溢出的类找出来，这里是对比多个对快照。</p><p>还有一种对比直方图的方式，首先通过 Window 菜单打开 Navigation History 视图，选中直方图右键并选中 Add to Compare Basket项目，将直方图添加到 Compare Basket 中。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/11/548db33968616d6ce2ea2d87f8b8bb57.png" alt=""><br>然后在 Compare Basket 中点击右上角的  按钮，可以分别列出对比的所有结果，见下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/11/1e3ec66f66b72a05eec686a24c2c4df6.png" alt=""><br>并且在上面的可以设置不同的对比方式。<br><img src="https://www.javatang.com/wp-content/uploads/2017/11/cb8e6e3c8bc871bd0d65a952aa572b94.png" alt=""></p><h3 id="Dominator-Tree视图"><a href="#Dominator-Tree视图" class="headerlink" title="Dominator Tree视图"></a>Dominator Tree视图</h3><p>点击工具栏上的<img src="https://www.javatang.com/wp-content/uploads/2017/10/5931b0544ead20fc50aba5efd828385e.png" alt="">图标可以打开Dominator Tree（支配树）视图，在此视图中列出了每个对象（Object Instance）与其引用关系的树状结构，同时包含了占用内存的大小和百分比。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftlzl15q38j30tf0lm47m.jpg" alt=""><br>通过Dominator Tree视图可以很容易的找出占用内存最多的几个对象（根据Retained Heap或Percentage排序），和Histogram类似，可以通过不同的方式进行分组显示：<br><img src="https://www.javatang.com/wp-content/uploads/2017/11/2235da535545f94b3233c22f0eea1302.png" alt=""></p><h3 id="重点：定位溢出源"><a href="#重点：定位溢出源" class="headerlink" title="重点：定位溢出源"></a>重点：定位溢出源</h3><p>Histogram视图和Dominator Tree视图的角度不同，前者是基于类的角度，后者是基于对象实例的角度，并且可以更方便的看出其引用关系。</p><p>首先，在两个视图中找出疑似溢出的对象或者类（可以通过Retained Heap排序，并且可以在Class Name中输入正则表达式的关键词只显示指定的类名），然后右键选择Path To GC Roots（Histogram中没有此项）或Merge Shortest Paths to GC Roots，然后选择 exclude all phantom/weak/soft etc. reference：<br><img src="https://www.javatang.com/wp-content/uploads/2017/11/0a35317d8a0291b8c5c6672ff6d17d0e.png" alt=""><br>GC Roots意为GC根节点，其含义见上面的 GC Roots和Reference Chain 部分，后面的 exclude all phantom/weak/soft etc. reference 意思是排除虚引用、弱引用和软引用，即只剩下强引用，因为除了强引用之外，其他的引用都可以被JVM GC掉，如果一个对象始终无法被GC，就说明有强引用存在，从而导致在GC的过程中一直得不到回收，最终就内存溢出了。</p><p>通过结果就可以很方便的定位到具体的代码，然后分析是什么原因无法释放该对象，比如被缓存了或者没有使用单例模式等等。</p><p>下面是执行的结果：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftlzp79sm7j30sp0kdgsc.jpg" alt=""><br>上图中保留了大量的user 引用，和我们手动制造的内存溢出对应</p><h3 id="后续观察"><a href="#后续观察" class="headerlink" title="后续观察"></a>后续观察</h3><p>上面是一个非常简单的内存异常分析过程，生产环境情况会复杂很多。<br>生产环境根据上面分析的结果对问题进行处理之后，再对照之前的操作，看看对象是否还再持续增长，如果没有就说明这个地方的问题已经解决了。</p><p>最后再用 jstat 持续跟踪一段时间，看看Old和Perm区的内存是否最终稳定在一个范围之内，如果长时间稳定在一个范围说明溢出问题得到了解决，否则还要继续进行分析和处理，一直到稳定为止。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/11/08/11582145.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;手动构建堆内存溢出：&quot;&gt;&lt;a href=&quot;#手动构建堆内存溢出：&quot; class=&quot;headerlink&quot; title=&quot;手动构建堆内存溢出：&quot;&gt;&lt;/a&gt;手动构建堆内存溢出：&lt;/h3&gt;&lt;p&gt;使用 asm 构造 class，后面模拟非堆内存溢出&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * https://blog.csdn.net/bolg_hero/article/details/78189621&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 继承ClassLoader是为了方便调用defineClass方法，因为该方法的定义为protected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Metaspace extends ClassLoader &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; createClasses() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 类持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes = new ArrayList&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 循环1000w次生成1000w个不同的类。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 0; i &amp;lt; 10000000; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ClassWriter cw = new ClassWriter(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 定义一个类名称为Class&amp;#123;i&amp;#125;，它的访问域为public，父类为java.lang.Object，不实现任何接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, &amp;quot;Class&amp;quot; + i, null,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;java/lang/Object&amp;quot;, null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 定义构造函数&amp;lt;init&amp;gt;方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            MethodVisitor mw = cw.visitMethod(Opcodes.ACC_PUBLIC, &amp;quot;&amp;lt;init&amp;gt;&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;()V&amp;quot;, null, null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 第一个指令为加载this&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mw.visitVarInsn(Opcodes.ALOAD, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 第二个指令为调用父类Object的构造函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mw.visitMethodInsn(Opcodes.INVOKESPECIAL, &amp;quot;java/lang/Object&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;&amp;lt;init&amp;gt;&amp;quot;, &amp;quot;()V&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 第三条指令为return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mw.visitInsn(Opcodes.RETURN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mw.visitMaxs(1, 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mw.visitEnd();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Metaspace test = new Metaspace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            byte[] code = cw.toByteArray();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 定义类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class&amp;lt;?&amp;gt; exampleClass = test.defineClass(&amp;quot;Class&amp;quot; + i, code, 0, code.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            classes.add(exampleClass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return classes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jvm概览</title>
    <link href="https://yefan813.github.io/2018/07/23/jvm%E6%A6%82%E8%A7%88/"/>
    <id>https://yefan813.github.io/2018/07/23/jvm%E6%A6%82%E8%A7%88/</id>
    <published>2018-07-23T15:54:55.000Z</published>
    <updated>2018-08-31T07:24:42.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h2><ul><li>标准参数</li><li>X 参数</li><li>XX 参数</li></ul><h3 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h3><ul><li>-help</li><li>-server :选择 “server” VM,默认 VM 是 server,因为您是在服务器类计算机上运行</li><li>-client</li><li>-version :输出产品版本并退出</li><li>-showversion :输出产品版本并继续</li><li>-cp :&lt;目录和 zip/jar 文件的类搜索路径&gt;</li><li>-classpath:&lt;目录和 zip/jar 文件的类搜索路径&gt;用 : 分隔的目录, JAR 档案和 ZIP 档案列表, 用于搜索类文件。</li></ul><a id="more"></a><h3 id="非标准参数-X"><a href="#非标准参数-X" class="headerlink" title="非标准参数: -X"></a>非标准参数: -X</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ftk8xya9lnj314415gk3n.jpg" alt=""><br>例如：<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ftk921u5dsj31120fgae8.jpg" alt=""></p><h3 id="XX参数分类"><a href="#XX参数分类" class="headerlink" title="XX参数分类"></a>XX参数分类</h3><ul><li>Boolean类型</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ftk93moo66j30p806dtad.jpg" alt=""></p><ul><li><p>非 Boolean 类型<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ftk97wn9i8j30qo065abs.jpg" alt=""></p></li><li><p>-Xmx -Xms<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ftk9ay3x0kj30xj0e2mzu.jpg" alt=""></p></li></ul><h2 id="查看-JVM-运行时参数"><a href="#查看-JVM-运行时参数" class="headerlink" title="查看 JVM 运行时参数"></a>查看 JVM 运行时参数</h2><ul><li>-XX:+PrintFlagsInitial 打印初始值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#java  -XX:+PrintFlagsInitial -version ##显示当前命令进程的参数信息</span><br></pre></td></tr></table></figure><ul><li>-XX:+PrintFlagsFinal 打印最终值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#java  -XX:+PrintFlagsFinal -version ##显示当前命令进程的参数信息</span><br></pre></td></tr></table></figure><ul><li>-XX:+UnlockExperimentalVMOptions解锁实验参数 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#java  -XX:+UnlockExperimentalVMOptions -version ##显示当前命令进程的参数信息</span><br></pre></td></tr></table></figure><ul><li>-XX:+UnlockDiagnosticOptions解锁诊断参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#java  -XX:+UnlockDiagnosticOptions -version ##显示当前命令进程的参数信息</span><br></pre></td></tr></table></figure><h3 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h3><p><code>jps [ options ] [ hostid ]</code><br><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftk9x9pvm5j30x80cnabp.jpg" alt=""></p><h3 id="jinfo-查看运行时参数"><a href="#jinfo-查看运行时参数" class="headerlink" title="jinfo 查看运行时参数"></a>jinfo 查看运行时参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jinfo [ option ] pid</span><br><span class="line"></span><br><span class="line">jinfo [ option ] executable core</span><br><span class="line"></span><br><span class="line">jinfo [ option ] [ servier-id ] remote-hostname-or-IP</span><br><span class="line"></span><br><span class="line">option</span><br><span class="line">The command-line options. See Options.</span><br><span class="line"></span><br><span class="line">pid</span><br><span class="line">The process ID for which the configuration information is to be printed. The process must be a Java process. To get a list of Java processes running on a machine, use the jps(1) command.</span><br><span class="line"></span><br><span class="line">executable</span><br><span class="line">The Java executable from which the core dump was produced.</span><br><span class="line"></span><br><span class="line">core</span><br><span class="line">The core file for which the configuration information is to be printed.</span><br><span class="line"></span><br><span class="line">remote-hostname-or-IP</span><br><span class="line">The remote debug server hostname or IP address. See jsadebugd(1).</span><br><span class="line"></span><br><span class="line">server-id</span><br><span class="line">An optional unique ID to use when multiple debug servers are running on the same remote host.</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">The jinfo command prints Java configuration information for a specified Java process or core file or a remote debug server. The configuration information includes Java system properties and Java Virtual Machine (JVM) command-line flags. If the specified process is running on a 64-bit JVM, then you might need to specify the -J-d64 option, for example: jinfo -J-d64 -sysprops pid.</span><br><span class="line"></span><br><span class="line">This utility is unsupported and might not be available in future releases of the JDK. In Windows Systems where dbgeng.dll is not present, Debugging Tools For Windows must be installed to have these tools working. The PATH environment variable should contain the location of the jvm.dll that is used by the target process or the location from which the crash dump file was produced. For example, set PATH=%JDK_HOME%\jre\bin\client;%PATH% .</span><br><span class="line"></span><br><span class="line">Options</span><br><span class="line">no-option</span><br><span class="line">Prints both command-line flags and system property name-value pairs.</span><br><span class="line"></span><br><span class="line">-flag name</span><br><span class="line">Prints the name and value of the specified command-line flag.</span><br><span class="line"></span><br><span class="line">-flag [+|-]name</span><br><span class="line">enables or disables the specified Boolean command-line flag.</span><br><span class="line"></span><br><span class="line">-flag name=value</span><br><span class="line">Sets the specified command-line flag to the specified value.</span><br><span class="line"></span><br><span class="line">-flags</span><br><span class="line">Prints command-line flags passed to the JVM.</span><br><span class="line"></span><br><span class="line">-sysprops</span><br><span class="line">Prints Java system properties as name-value pairs.</span><br><span class="line"></span><br><span class="line">-h</span><br><span class="line">Prints a help message.</span><br><span class="line"></span><br><span class="line">-help</span><br><span class="line">Prints a help message.</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">⇒  jinfo -flag MaxHeapSize 5796  ##查看最大内存</span><br><span class="line">-XX:MaxHeapSize=4294967296</span><br><span class="line"></span><br><span class="line">jinfo -flag UseConcMarkSweepGC 5796 ##查看是否垃圾回收器 +使用 -表示未使用</span><br><span class="line">-XX:-UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line">⇒  jinfo -flag UseG1GC 5796 ##查看是否垃圾回收器 +使用 -表示未使用</span><br><span class="line">-XX:-UseG1GC</span><br><span class="line"></span><br><span class="line">⇒  jinfo -flag UseParallelGC 5796 ##查看是否垃圾回收器 +使用 -表示未使用</span><br><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure><h3 id="jstat-查看-JVM-统计信息"><a href="#jstat-查看-JVM-统计信息" class="headerlink" title="jstat 查看 JVM 统计信息"></a>jstat 查看 JVM 统计信息</h3><ul><li>查看类装载信息</li><li>查看垃圾收集信息</li><li>查看JIT 编译信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">jstat [ generalOption | outputOptions vmid [ interval[s|ms] [ count ] ]</span><br><span class="line"></span><br><span class="line">generalOption: -help 、 -options</span><br><span class="line"></span><br><span class="line">outputOptions:</span><br><span class="line">class: 显示有关类加载器行为的统计信息.</span><br><span class="line"></span><br><span class="line">compiler: 显示有关Java HotSpot VM实时编译器（JIT）行为的统计信息.</span><br><span class="line"></span><br><span class="line">gc: 显示有关垃圾回收堆行为的统计信息.</span><br><span class="line"></span><br><span class="line">gccapacity: 显示有关代的容量及其相应空间的统计信息.</span><br><span class="line"></span><br><span class="line">gccause: 显示有关垃圾收集统计信息的摘要（与-gcutil相同），以及最后一个和当前（适用时）垃圾收集事件的原因.</span><br><span class="line"></span><br><span class="line">gcnew: 显示新生代行为的统计信息.</span><br><span class="line"></span><br><span class="line">gcnewcapacity: 显示有关新生代及其相应空间大小的统计信息.</span><br><span class="line"></span><br><span class="line">gcold: 显示有关老年代和元空间统计信息行为的统计信息.</span><br><span class="line"></span><br><span class="line">gcoldcapacity: 显示有关老年代大小的统计信息.</span><br><span class="line"></span><br><span class="line">gcmetacapacity: 显示有关元空间大小的统计信息.</span><br><span class="line"></span><br><span class="line">gcutil: 显示有关垃圾收集统计信息的摘要.</span><br><span class="line"></span><br><span class="line">printcompilation: 显示Java HotSpot VM编译方法统计信息.</span><br><span class="line"></span><br><span class="line">参考：[链接](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHIGDGJ)</span><br></pre></td></tr></table></figure><h5 id="gc-输出结果"><a href="#gc-输出结果" class="headerlink" title="-gc 输出结果"></a>-gc 输出结果</h5><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ftkaz5fm0ej311c0j7tib.jpg" alt=""></p><p>这里不得不提一下 JVM 内存结构：<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ftkb1vazonj30w40pk7eo.jpg" alt=""></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/" target="_blank" rel="noopener">官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM参数类型&quot;&gt;&lt;a href=&quot;#JVM参数类型&quot; class=&quot;headerlink&quot; title=&quot;JVM参数类型&quot;&gt;&lt;/a&gt;JVM参数类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;标准参数&lt;/li&gt;
&lt;li&gt;X 参数&lt;/li&gt;
&lt;li&gt;XX 参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;标准参数&quot;&gt;&lt;a href=&quot;#标准参数&quot; class=&quot;headerlink&quot; title=&quot;标准参数&quot;&gt;&lt;/a&gt;标准参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;-help&lt;/li&gt;
&lt;li&gt;-server :选择 “server” VM,默认 VM 是 server,因为您是在服务器类计算机上运行&lt;/li&gt;
&lt;li&gt;-client&lt;/li&gt;
&lt;li&gt;-version :输出产品版本并退出&lt;/li&gt;
&lt;li&gt;-showversion :输出产品版本并继续&lt;/li&gt;
&lt;li&gt;-cp :&amp;lt;目录和 zip/jar 文件的类搜索路径&amp;gt;&lt;/li&gt;
&lt;li&gt;-classpath:&amp;lt;目录和 zip/jar 文件的类搜索路径&amp;gt;用 : 分隔的目录, JAR 档案和 ZIP 档案列表, 用于搜索类文件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java 引用类型</title>
    <link href="https://yefan813.github.io/2018/07/12/java-reference/"/>
    <id>https://yefan813.github.io/2018/07/12/java-reference/</id>
    <published>2018-07-12T10:09:43.000Z</published>
    <updated>2018-08-31T07:23:38.118Z</updated>
    
    <content type="html"><![CDATA[<p><strong>java中提供了四个级别的引用：</strong></p><ol><li>强引用（Final Reference）</li><li>软引用(Soft Reference)</li><li>弱引用(Weak Reference)</li><li>虚引用(Phantom Reference)</li></ol><p><strong>这四个引用定义在java.lang.ref的包下</strong><br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft80n8gk8uj306104o0sr.jpg" alt=""></p><a id="more"></a><p><strong>强引用（ Final Reference ）</strong><br> 就是指在程序代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<br>  强引用具备以下三个个特点：</p><blockquote><p>1.强引用可以直接访问目标对象；<br>2.强引用锁指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常也不回收强引用所指向的对象；<br>3.强应用可能导致内存泄露；</p></blockquote><p>整个FinalReference类的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.ref;</span><br><span class="line"><span class="comment">/* Final references, used to implement finalization */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类定义中可以看出，只有一个构造函数，根据所给的对象的引用和引用队列构造一个强引用。</p><hr><p><strong>软引用（ Soft Reference ）</strong><br>  是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。<br>  对于软引用关联着的对象，如果内存充足，则垃圾回收器不会回收该对象，如果内存不够了，就会回收这些对象的内存。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。<br>  案例：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftRefTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;MyObject&gt; softQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 垃圾回收器准备释放内存的时候，会先调用finalize()</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"MyObject's finalize called"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I am MyObject"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        Reference&lt;MyObject&gt; obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                obj = (Reference&lt;MyObject&gt;)softQueue.remove();  <span class="comment">//如果队列没有数据一致阻塞等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(obj != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"Object for SoftReference is "</span>+obj.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyObject object = <span class="keyword">new</span> MyObject();</span><br><span class="line">        SoftReference&lt;MyObject&gt; softRef = <span class="keyword">new</span> SoftReference&lt;&gt;(object,softQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CheckRefQueue()).start();</span><br><span class="line"></span><br><span class="line">        object = <span class="keyword">null</span>;    <span class="comment">//删除强引用</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"After GC: Soft Get= "</span>+softRef.get());</span><br><span class="line">        System.out.println(<span class="string">"分配大块内存"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">928</span>];</span><br><span class="line">        System.out.println(<span class="string">"After new byte[]:Soft Get= "</span>+softRef.get());</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行参数1：<br><code>-Xmx5M</code></p><p>运行结果1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">After GC: Soft Get= I am MyObject</span><br><span class="line">分配大块内存</span><br><span class="line">MyObject&apos;s finalize called</span><br><span class="line">Object for SoftReference is null</span><br><span class="line">After new byte[]:Soft Get= null</span><br></pre></td></tr></table></figure><p>运行参数2：</p><p><code>-Xmx5M -XX:PrintGCDetails</code></p><p>运行结果2（关于GC日志可以查看《Java堆内存<a href="http://blog.csdn.net/u013256816/article/details/50764532》）：" target="_blank" rel="noopener">http://blog.csdn.net/u013256816/article/details/50764532》）：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[GC [PSYoungGen: 680K-&gt;504K(2560K)] 680K-&gt;512K(6144K), 0.0040658 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC [PSYoungGen: 504K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;482K(3584K)] 512K-&gt;482K(6144K) [PSPermGen: 2491K-&gt;2490K(21504K)], 0.0188479 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] </span><br><span class="line">After GC: Soft Get= I am MyObject</span><br><span class="line">分配大块内存</span><br><span class="line">[GC [PSYoungGen: 123K-&gt;64K(2560K)] 605K-&gt;546K(7680K), 0.0004285 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC [PSYoungGen: 64K-&gt;64K(2560K)] 546K-&gt;546K(7680K), 0.0003019 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC [PSYoungGen: 64K-&gt;0K(2560K)] [ParOldGen: 482K-&gt;482K(4608K)] 546K-&gt;482K(7168K) [PSPermGen: 2493K-&gt;2493K(21504K)], 0.0094748 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC [PSYoungGen: 0K-&gt;0K(2560K)] 482K-&gt;482K(7680K), 0.0003759 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 482K-&gt;472K(5120K)] 482K-&gt;472K(7680K) [PSPermGen: 2493K-&gt;2493K(21504K)], 0.0101017 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] </span><br><span class="line">MyObject&apos;s finalize called</span><br><span class="line">Object for SoftReference is null</span><br><span class="line">After new byte[]:Soft Get= null</span><br><span class="line">[GC [PSYoungGen: 122K-&gt;32K(2560K)] 5235K-&gt;5144K(7680K), 0.0004806 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC [PSYoungGen: 32K-&gt;0K(2560K)] [ParOldGen: 5112K-&gt;5112K(5120K)] 5144K-&gt;5112K(7680K) [PSPermGen: 2493K-&gt;2493K(21504K)], 0.0136270 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 20K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 1% used [0x00000000ffd00000,0x00000000ffd05250,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 5120K, used 5112K [0x00000000ff800000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 5120K, 99% used [0x00000000ff800000,0x00000000ffcfe188,0x00000000ffd00000)</span><br><span class="line"> PSPermGen       total 21504K, used 2500K [0x00000000fa600000, 0x00000000fbb00000, 0x00000000ff800000)</span><br><span class="line">  object space 21504K, 11% used [0x00000000fa600000,0x00000000fa871190,0x00000000fbb00000)</span><br></pre></td></tr></table></figure><p>加入 -XX:PrintGCDetails参数运行可以更形象的看到GC回收的细节。<br>  这个案例1中，首先构造MyObject对象，并将其赋值给object变量，构成强引用。然后使用SoftReference构造这个MyObject对象的软引用softRef，并注册到softQueue引用队列。当softRef被回收时，会被加入softQueue队列。设置obj=null，删除这个强引用，因此，系统内对MyObject对象的引用只剩下软引用。此时，显示调用GC，通过软引用的get()方法，取得MyObject对象的引用，发现对象并未被回收，这说明GC在内存充足的情况下，不会回收软引用对象。<br>  接着，请求一块大的堆空间5<em>1024</em>928，这个操作会使系统堆内存使用紧张，从而产生新一轮的GC。在这次GC后，softRef.get()不再返回MyObject对象，而是返回null，说明在系统内存紧张的情况下，软引用被回收。软引用被回收时，会被加入注册的引用队列。<br>   如果将上面案例中的数组再改大点，比如5<em>1024</em>1024，就会抛出OOM异常：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">After GC: Soft Get= I am MyObject</span><br><span class="line">分配大块内存</span><br><span class="line">MyObject&apos;s finalize called</span><br><span class="line">Object for SoftReference is null</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at collections.ref.SoftRefTest.main(SoftRefTest.java:58)</span><br></pre></td></tr></table></figure><p>软引用主要应用于内存敏感的高速缓存，在android系统中经常使用到。一般情况下，Android应用会用到大量的默认图片，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软引用技术来避免这个问题发生。SoftReference可以解决oom的问题，每一个对象通过软引用进行实例化，这个对象就以cache的形式保存起来，当再次调用这个对象时，那么直接通过软引用中的get（）方法，就可以得到对象中中的资源数据，这样就没必要再次进行读取了，直接从cache中就可以读取得到，当内存将要发生OOM的时候，GC会迅速把所有的软引用清除，防止oom发生。</p><hr><p><strong>弱引用（ Weak Reference ）</strong><br>    用来描述非必须的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发送之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个注册引用队列中。<br>  我们略微修改一下案例1的代码，如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package collections.ref;</span><br><span class="line"></span><br><span class="line">import java.lang.ref.Reference;</span><br><span class="line">import java.lang.ref.ReferenceQueue;</span><br><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line">public class WeakRefTest</span><br><span class="line">&#123;</span><br><span class="line">    private static ReferenceQueue&lt;MyObject&gt; weakQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static class MyObject&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void finalize() throws Throwable</span><br><span class="line">        &#123;</span><br><span class="line">            super.finalize();</span><br><span class="line">            System.out.println(&quot;MyObject&apos;s finalize called&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString()</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;I am MyObject&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class CheckRefQueue implements Runnable</span><br><span class="line">    &#123;</span><br><span class="line">        Reference&lt;MyObject&gt; obj = null;</span><br><span class="line">        @Override</span><br><span class="line">        public void run()</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                obj = (Reference&lt;MyObject&gt;)weakQueue.remove(); //阻塞等待</span><br><span class="line">            &#125;</span><br><span class="line">            catch (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(obj != null)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;删除的弱引用为：&quot;+obj+&quot;  but获取弱引用的对象obj.get()=&quot;+obj.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        MyObject object = new MyObject();</span><br><span class="line">        Reference&lt;MyObject&gt; weakRef = new WeakReference&lt;&gt;(object,weakQueue);</span><br><span class="line">        System.out.println(&quot;创建的弱引用为：&quot;+weakRef);</span><br><span class="line">        new Thread(new CheckRefQueue()).start();</span><br><span class="line"></span><br><span class="line">        object = null;</span><br><span class="line">        System.out.println(&quot;Before GC: Weak Get= &quot;+weakRef.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;After GC: Weak Get= &quot;+weakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不加参数运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建的弱引用为：java.lang.ref.WeakReference@<span class="number">29e07</span>d3e</span><br><span class="line">Before GC: Weak Get= I am MyObject</span><br><span class="line">After GC: Weak Get= <span class="keyword">null</span></span><br><span class="line">MyObject<span class="string">'s finalize called</span></span><br><span class="line"><span class="string">删除的弱引用为：java.lang.ref.WeakReference@29e07d3e  but获取弱引用的对象obj.get()=null</span></span><br></pre></td></tr></table></figure><p>可以看到，在GC之前，弱引用对象并未被垃圾回收器发现，因此通过 weakRef.get()可以获取对应的对象引用。但是只要进行垃圾回收，弱引用一旦被发现，便会立即被回收，并加入注册引用队列中。此时再试图通过weakRef.get()获取对象的引用就会失败。</p><blockquote><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起来加速系统的作用。</p></blockquote><hr><p><strong>虚引用（Phantom Reference)</strong></p><p>虚引用（Phantom Reference)<br>  虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个持有虚引用的对象，和没有引用几乎是一样的，随时都有可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。<br>  虚引用中get方法的实现如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到永远返回null.<br>  我们再来修改一下案例1的代码：<br>  <br>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collections.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomRefTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;MyObject&gt; phanQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"MyObject's finalize called"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I am MyObject"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        Reference&lt;MyObject&gt; obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                obj = (Reference&lt;MyObject&gt;)phanQueue.remove();</span><br><span class="line">                System.out.println(<span class="string">"删除的虚引用为："</span>+obj+<span class="string">"  but获取虚引用的对象obj.get()="</span>+obj.get());</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyObject object = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Reference&lt;MyObject&gt; phanRef = <span class="keyword">new</span> PhantomReference&lt;&gt;(object,phanQueue);</span><br><span class="line">        System.out.println(<span class="string">"创建的虚引用为："</span>+phanRef);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CheckRefQueue()).start();</span><br><span class="line"></span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+i+++<span class="string">"次gc"</span>);</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建的虚引用为：java.lang.ref.PhantomReference@3a6646fc</span><br><span class="line">第1次gc</span><br><span class="line">MyObject&apos;s finalize called</span><br><span class="line">第2次gc</span><br><span class="line">删除的虚引用为：java.lang.ref.PhantomReference@3a6646fc  but获取虚引用的对象obj.get()=null</span><br></pre></td></tr></table></figure><p> 可以看到，再经过一次GC之后，系统找到了垃圾对象，并调用finalize()方法回收内存，但没有立即加入回收队列。第二次GC时，该对象真正被GC清楚，此时，加入虚引用队列。<br>  虚引用的最大作用在于跟踪对象回收，清理被销毁对象的相关资源。<br>  通常当对象不被使用时，重载该对象的类的finalize方法可以回收对象的资源。但是如果使用不慎，会使得对象复活，譬如这么编写finalize方法：<br>  <br>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test obj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上面这个类Test中obj = new Test();然后obj=null；之后调用System.gc()企图销毁对象，但是很抱歉，不管你调用多少次System.gc()都没有什么用，除非你在下面的代码中再就obj=null;这样才能回收对象，这是因为JVM对某一个对象至多只执行一次被重写的finalize方法。<br>  上面的小片段说明重写finalize的方法并不是很靠谱，可以使用虚引用来清理对象所占用的资源。<br>  如下代码所示：<br>  <br>  <br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomRefTest2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;MyObject&gt; phanQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Reference&lt;MyObject&gt;,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">            System.out.println(<span class="string">"MyObject's finalize called"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I am MyObject"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        Reference&lt;MyObject&gt; obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                obj = (Reference&lt;MyObject&gt;)phanQueue.remove();</span><br><span class="line">                Object value = map.get(obj);</span><br><span class="line">                System.out.println(<span class="string">"clean resource:"</span>+value);</span><br><span class="line">                map.remove(obj);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"删除的虚引用为："</span>+obj+<span class="string">"  but获取虚引用的对象obj.get()="</span>+obj.get());</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyObject object = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Reference&lt;MyObject&gt; phanRef = <span class="keyword">new</span> PhantomReference&lt;&gt;(object,phanQueue);</span><br><span class="line">        System.out.println(<span class="string">"创建的虚引用为："</span>+phanRef);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CheckRefQueue()).start();</span><br><span class="line">        map.put(phanRef, <span class="string">"Some Resources"</span>);</span><br><span class="line"></span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+i+++<span class="string">"次gc"</span>);</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建的虚引用为：java.lang.ref.PhantomReference@6a07348e</span><br><span class="line">第1次gc</span><br><span class="line">MyObject&apos;s finalize called</span><br><span class="line">第2次gc</span><br><span class="line">clean resource:Some Resources</span><br><span class="line">删除的虚引用为：java.lang.ref.PhantomReference@6a07348e  but获取虚引用的对象obj.get()=null</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;java中提供了四个级别的引用：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;强引用（Final Reference）&lt;/li&gt;
&lt;li&gt;软引用(Soft Reference)&lt;/li&gt;
&lt;li&gt;弱引用(Weak Reference)&lt;/li&gt;
&lt;li&gt;虚引用(Phantom Reference)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;这四个引用定义在java.lang.ref的包下&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1ft80n8gk8uj306104o0sr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker Compose</title>
    <link href="https://yefan813.github.io/2018/07/11/Docker-Compose/"/>
    <id>https://yefan813.github.io/2018/07/11/Docker-Compose/</id>
    <published>2018-07-11T07:34:32.000Z</published>
    <updated>2018-08-31T07:23:00.359Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsy1fmufhxj30j50agju1.jpg" alt="image"><br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsy1g0w74ej30hy0b6wg6.jpg" alt="image"><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fsy1jqewqwj30jj0b9tc7.jpg" alt="image"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fsy1xfo1tdj30mq0c5ju9.jpg" alt="image"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fsy1y4fkbtj30lp0c7djj.jpg" alt="image"></p><p>远程 image 例如：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fsy1ovdmngj30mh0cf79r.jpg" alt="image"></p><p>本地 dockFile 例如：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsy1qccx18j30jw0cgmz9.jpg" alt="image"></p><a id="more"></a><p>详细说明：<br>示例1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  wordpress:     <span class="comment">##container 名称</span></span><br><span class="line">    image: wordpress  <span class="comment">##image名称 远程的</span></span><br><span class="line">    ports:  <span class="comment">##端口映射</span></span><br><span class="line">      - <span class="number">8080</span>:<span class="number">80</span></span><br><span class="line">    environment:  <span class="comment">##环境变量</span></span><br><span class="line">      WORDPRESS_DB_HOST: mysql</span><br><span class="line">      WORDPRESS_DB_PASSWORD: root</span><br><span class="line">    networks:   <span class="comment">##指定网络</span></span><br><span class="line">      - my-bridge  <span class="comment">## 对应最下面的networks</span></span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">    volumes:  <span class="comment">##制定挂在目录</span></span><br><span class="line">      - mysql-data:/var/lib/mysql  <span class="comment">## mysql-data 对应下面的volumes</span></span><br><span class="line">    networks:</span><br><span class="line">      - my-bridge</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mysql-data:   <span class="comment">## 创建一个volumes</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  my-bridge:   <span class="comment">## 创建一个名为my-bridge的networks</span></span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure></p><p>示例2：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsy1u4l0ktj30nm0kwad6.jpg" alt="image"></p><p>docker-compose cli：<br><a href="http://www.cnblogs.com/liubin0509/p/6178351.html" target="_blank" rel="noopener">传送门</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="keyword">exec</span> mysql /bin/bash <span class="comment">##进去docker-compose中的mysql 执行/bin/bash</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fsy1fmufhxj30j50agju1.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fsy1g0w74ej30hy0b6wg6.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fsy1jqewqwj30jj0b9tc7.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fsy1xfo1tdj30mq0c5ju9.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fsy1y4fkbtj30lp0c7djj.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;远程 image 例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fsy1ovdmngj30mh0cf79r.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;本地 dockFile 例如：&lt;br&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fsy1qccx18j30jw0cgmz9.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="https://yefan813.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
