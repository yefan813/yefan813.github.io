<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奋斗不息</title>
  
  <subtitle>态度决定一切</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yefan813.github.io/"/>
  <updated>2020-04-01T09:46:13.156Z</updated>
  <id>https://yefan813.github.io/</id>
  
  <author>
    <name>Evan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka数据存储结构详解</title>
    <link href="https://yefan813.github.io/2020/04/01/Kafka%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yefan813.github.io/2020/04/01/Kafka%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-01T09:44:59.000Z</published>
    <updated>2020-04-01T09:46:13.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka存储结构详解"><a href="#Kafka存储结构详解" class="headerlink" title="Kafka存储结构详解"></a>Kafka存储结构详解</h1><h2 id="1-Topic"><a href="#1-Topic" class="headerlink" title="1 Topic"></a>1 Topic</h2><ul><li>用一个Topic的消息可以分布在一个或者多个broker上</li><li>一个 Topic 包含一个或者多个 partation</li><li>每个消息都属于且仅属于一个Topic</li><li>Producer 发布数据时，必须指定该消息发布到哪一个 Topic 上</li><li>Consumer 订阅消息时，必须制定订阅哪个 Topic</li></ul><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-082344.png" alt=""></p><h2 id="2-Partition"><a href="#2-Partition" class="headerlink" title="2 Partition"></a>2 Partition</h2><ul><li>物理概念，一个 partition 只分布在一个 broker 上（不考虑备份）</li><li>一个 partition 物理上对应一个文件夹</li><li>一个 partition 包含多个 segment（逻辑上的概念，不存在具体物理文件）</li><li>一个 segment 对应一个文件</li><li>segment由一个个不变记录组成</li><li>记录只会被 append 到 segment，不会被单独修改或者删除</li><li>清除过期日志时，直接删除一个或者多个 segment</li></ul><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-065909.png" alt=""></p><p><strong>topic名称-分区数命名</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//分布在不同的broker节点上  </span><br><span class="line">test-topic-0  </span><br><span class="line">test-topic-1  </span><br><span class="line">test-topic-2</span><br></pre></td></tr></table></figure></p><p><strong>partition文件存储方式</strong><br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-075742.png" alt=""></p><h3 id="疑问：-为什么需要分区"><a href="#疑问：-为什么需要分区" class="headerlink" title="疑问： 为什么需要分区"></a>疑问： 为什么需要分区</h3><p>为了性能考虑，如果不分区每个topic的消息只存在一个broker上，那么所有的消费者都是从这个broker上消费消息，那么单节点的broker成为性能的瓶颈，如果有分区的话生产者发过来的消息分别存储在各个broker不同的partition上，这样消费者可以并行的从不同的broker不同的partition上读消息，实现了水平扩展。 </p><p style="color:red">总结一句话：可以多个 broker 同事操作，提高并行度</p><h3 id="2-2-分区文件下存了哪些东西"><a href="#2-2-分区文件下存了哪些东西" class="headerlink" title="2.2 分区文件下存了哪些东西"></a>2.2 分区文件下存了哪些东西</h3><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-082719.png" alt=""></p><h2 id="3-Segment"><a href="#3-Segment" class="headerlink" title="3 Segment"></a>3 Segment</h2><p>segment 是个逻辑上的概念，并不存在真实的 segment 文件<br>Segment 是由一个 .index 和 一个 .log文件组成的。所以从可看到一个上图一个 partition 存在一个或者多个 segment。</p><ul><li>.index 文件是索引文件用来快速的查找真实消息数据</li><li>.log 文件是用来存储数据的文件<br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-074720.png" alt=""><br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-084529.png" alt=""></li></ul><h3 id="疑问：-为什么有了-Partition-还需要-segment"><a href="#疑问：-为什么有了-Partition-还需要-segment" class="headerlink" title="疑问： 为什么有了 Partition 还需要 segment"></a>疑问： 为什么有了 Partition 还需要 segment</h3><p>通过上面的图，可以了解到一个 partition 下存在多个 segment，一个 segment 由有一个.index和一个.log文件组成，如果不用这种方式，那可以使用一个.index和一个.log文件组成（类似RocketMQ中使用CommitLog文件来保存所有的数据文件，由多个 indexfile 来存储索引文件）。这样的坏处是，随着消息的不断写入这个文件，由于kafka的消息不会做更新操作都是顺序写入的，如果做消息清理的时候只能删除文件的前面部分删除，不符合kafka顺序写入的设计，如果多个segment的话那就比较方便了，直接删除整个文件即可保证了每个segment的顺序写入。</p><p style="color:red">总结一句话：为了提高写入的效率，以及方便清除不需要的数据</p><h3 id="3-1-index文件内部存储了哪些数据"><a href="#3-1-index文件内部存储了哪些数据" class="headerlink" title="3.1 .index文件内部存储了哪些数据"></a>3.1 .index文件内部存储了哪些数据</h3><p>存储了对应数据文件的部分offset，以及 position（表示具体消息存储在log中的物理地址）。可以看待 offset 并不是连续的，而是每隔 6 个 offset 存储一条索引数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">offset: 1049 position: 16205  </span><br><span class="line">offset: 1065 position: 32410  </span><br><span class="line">offset: 1081 position: 48615  </span><br><span class="line">offset: 1097 position: 64820  </span><br><span class="line">offset: 1113 position: 81025  </span><br><span class="line">offset: 1129 position: 97230</span><br></pre></td></tr></table></figure></p><h4 id="疑问：-为什么-index-文件中这些-offset-不是连续的编号呢？"><a href="#疑问：-为什么-index-文件中这些-offset-不是连续的编号呢？" class="headerlink" title="疑问： 为什么 index 文件中这些 offset 不是连续的编号呢？"></a>疑问： 为什么 index 文件中这些 offset 不是连续的编号呢？</h4><p>因为index文件中并没有为数据文件中的每条消息都建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。这种存储方式叫做稀疏索引<br>也可以配置成稠密索引，带来的问题就是索引文件太大。但是查找效率会高一点</p><p></p><p style="color:red">总结一句话：减小 index 文件大小，可以将 index 文件内容加载到内存中，从而减小占用内存空间大小</p><p></p><h3 id="3-2-log文件存储了那些数据"><a href="#3-2-log文件存储了那些数据" class="headerlink" title="3.2 .log文件存储了那些数据"></a>3.2 .log文件存储了那些数据</h3><p>log数据文件中并不是直接存储数据，而是通过许多的message组成，message包含了实际的消息数据。<br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-091728.png" alt=""><br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-091807.png" alt=""></p><h2 id="4-消费者如何根据-offset-查找-message"><a href="#4-消费者如何根据-offset-查找-message" class="headerlink" title="4 消费者如何根据 offset 查找 message"></a>4 消费者如何根据 offset 查找 message</h2><p>假如我们想要读取offset=1066的message，需要通过下面2个步骤查找。</p><ol><li>查找segment file<br>00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件00000000000000001018.index的消息量起始偏移量为1019 = 1018 + 1.同样，第三个文件00000000000000002042.index的起始偏移量为2043=2042 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset 二分查找文件列表，就可以快速定位到具体文件。 当offset=1066时定位到00000000000000001018.index|log</li><li>通过segment file查找message<br>通过第一步定位到segment file，当offset=1066时，依次定位到00000000000000001018.index的元数据物理位置和00000000000000001018.log的物理偏移地址，此时我们只能拿到1065的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到offset=1066为止。每个message都有固定的格式很容易判断是否是下一条消息</li></ol><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-04-01-092404.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kafka存储结构详解&quot;&gt;&lt;a href=&quot;#Kafka存储结构详解&quot; class=&quot;headerlink&quot; title=&quot;Kafka存储结构详解&quot;&gt;&lt;/a&gt;Kafka存储结构详解&lt;/h1&gt;&lt;h2 id=&quot;1-Topic&quot;&gt;&lt;a href=&quot;#1-Topic&quot; c
      
    
    </summary>
    
    
    
      <category term="消息队列,MQ,Kafka" scheme="https://yefan813.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-MQ-Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Netty入门</title>
    <link href="https://yefan813.github.io/2020/03/26/Netty%E5%85%A5%E9%97%A8/"/>
    <id>https://yefan813.github.io/2020/03/26/Netty%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-26T12:53:58.000Z</published>
    <updated>2020-03-27T08:59:57.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在介绍 Netty之前一定要先搞明白同步和异步、阻塞和非阻塞、BIO、NIO、AIO 都是什么，然后有哪些优缺点，再来看 Netty 出现的原因，有哪些优势，使用场景是什么。这样循序渐进的学习，更容易理解。</p><h1 id="同步和异步、阻塞和非阻塞"><a href="#同步和异步、阻塞和非阻塞" class="headerlink" title="同步和异步、阻塞和非阻塞"></a>同步和异步、阻塞和非阻塞</h1><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h4 id="同步和异步关注的是消息通信机制"><a href="#同步和异步关注的是消息通信机制" class="headerlink" title="同步和异步关注的是消息通信机制"></a>同步和异步关注的是消息通信机制</h4><p><strong>同步</strong>：同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。</p><blockquote><p>举例：你去收发室问老大爷有没快递，老大爷说你等等，我找找，然后你就等啊等啊，可能 5s 分钟就找到了，可能一天才找到，你就一直等着知道大爷回答你</p></blockquote><p><strong>异步</strong>：异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用</p><blockquote><p>举例：你去收发室问老大爷有没快递，老大爷就说我找一下，找到了我给你打电话。然后你就直接走了，干自己的事去了</p></blockquote><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><h4 id="阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态"><a href="#阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态" class="headerlink" title="阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态."></a>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</h4><p><strong>阻塞</strong>：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</p><blockquote><p>举例：你去收发室问大爷有没快递，在大爷没回复你之前，你就把自己‘挂起’啥都不干，知道大爷回复你。</p></blockquote><p><strong>非阻塞</strong>：在不能立刻得到结果之前，该调用不会阻塞当前线程</p><blockquote><p>举例：你去收发室问大爷有没快递，然后你就跑去玩了，时不时的过来问一下是否有结果。</p></blockquote><h1 id="BIO-NIO-AIO是什么"><a href="#BIO-NIO-AIO是什么" class="headerlink" title="BIO/NIO/AIO是什么"></a>BIO/NIO/AIO是什么</h1><h2 id="BIO（Block-IO）"><a href="#BIO（Block-IO）" class="headerlink" title="BIO（Block IO）"></a>BIO（Block IO）</h2><p>同步阻塞，服务器实现模式是一个连接一个线程，即客户端有连接请求是服务度就需要启动一个线程进行处理。<br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-27-084253.png" alt=""></p><p><strong>优点</strong>：编写简单,小请求量可以接受</p><p><strong>缺点</strong>:针对高并发，超过100000的并发连接来说该方案并不可取，它所需要的线程资源太多，而且任何时候都可能存在大量线程处于阻塞状态，等待输入或者输出数据就绪，整个方案性能太差。</p><p>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        System.out.println(<span class="string">"启动服务器..."</span>);</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"等待客户端链接..."</span>);</span><br><span class="line">            <span class="comment">//accept()方法阻塞，直到有新的连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"客户已连接,创建新的线程处理"</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               handle(socket);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"读数据.."</span>);</span><br><span class="line">            <span class="comment">//read block method</span></span><br><span class="line">            <span class="keyword">int</span> len = socket.getInputStream().read(bytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"写数据.."</span>);</span><br><span class="line">            <span class="comment">//write block method</span></span><br><span class="line">            socket.getOutputStream().write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            socket.getOutputStream().flush();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        socket.getOutputStream().write(<span class="string">"hello server"</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"write over, wait for msg back"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = socket.getInputStream().read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="NIO（No-Block-IO）"><a href="#NIO（No-Block-IO）" class="headerlink" title="NIO（No-Block IO）"></a>NIO（No-Block IO）</h2><p>同步非阻塞，服务器实现是一个线程处理多个请求连接，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮训到连接有 IO 请求就进行处理</p><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-27-084320.png" alt=""></p><p>NIO核心组件：</p><ol><li>Channel: 对应JDK底层的Socket,它除了包含基本的I/O操作，如 bind(),connect()，read()，write()之外</li><li>Buffer: 缓存 Buffer</li><li>Selector:是 Java 非阻塞 I/O实现的关键，将通道Channel注册在 Selector上，如果某个通道 Channel发送 读或写事件，这个Channel处于就绪状态，会被Selector轮询出来，进而进行后续I/O操作</li></ol><p><strong>优点</strong>：使用 Java NIO可以让我们使用较少的线程处理很多连接，较少线程意味着减少了线程创建内存分配和线程上下文切换带来的开销。</p><p><strong>缺点</strong>：编程复杂，需要处理各种问题，API 使用难度大，在高负载下可靠和高效地处理和调度I/O操作是一项繁琐而且容易出错的任务，使用 NIO编程很容易出错。</p><p>代码示例：单线程处理连接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// set block is false</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"server is started, listen on :"</span> + serverSocketChannel.getLocalAddress());</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//注册监听客户端连接事件</span></span><br><span class="line">        <span class="comment">//注册 accept 监听事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//轮训查看，阻塞方法。监听是否有事件发生</span></span><br><span class="line">            System.out.println(<span class="string">"轮训查看是否有监听事件发生..."</span>);</span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//监听到有哪些 key 事件发生</span></span><br><span class="line">            System.out.println(<span class="string">"监听到事件发生..."</span>);</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//需要将 key remove 掉不然下次轮训还会处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">//获得 channel</span></span><br><span class="line">            System.out.println(<span class="string">"accept事件发生，建立一条通道"</span>);</span><br><span class="line">            ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//建立 channel</span></span><br><span class="line">                serverSocketChannel.accept();</span><br><span class="line">                <span class="comment">//设置通道是否阻塞</span></span><br><span class="line">                serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//在通道上放置一个 read 的监听事件</span></span><br><span class="line">                System.out.println(<span class="string">"在 channel 通道上注册 read 事件..."</span>);</span><br><span class="line">                serverSocketChannel.register(key.selector(),SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read事件发生..."</span>);</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//分配内存</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从通道读取数据</span></span><br><span class="line">                System.out.println(<span class="string">"读取数据..."</span>);</span><br><span class="line">                <span class="keyword">int</span> len = socketChannel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len));</span><br><span class="line">                &#125;</span><br><span class="line">                ByteBuffer bufferToWrite = ByteBuffer.wrap(<span class="string">"hello client"</span>.getBytes());</span><br><span class="line">                <span class="comment">//向通道写数据</span></span><br><span class="line">                socketChannel.write(bufferToWrite);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        socket.getOutputStream().write(<span class="string">"hello server"</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"write over, wait for msg back"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = socket.getInputStream().read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码示例：线程池处理连接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioPoolServer</span> </span>&#123;</span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// set block is false</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"server is started, listen on :"</span> + serverSocketChannel.getLocalAddress());</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//注册监听客户端连接事件</span></span><br><span class="line">        <span class="comment">//注册 accept 监听事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">"server run success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NioPoolServer server = <span class="keyword">new</span> NioPoolServer();</span><br><span class="line">        server.initServer(<span class="number">8000</span>);</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"selector 轮训是否有事件.."</span>);</span><br><span class="line">            <span class="comment">// block method</span></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"有客户端链接.."</span>);</span><br><span class="line">            ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel channel = serverSocketChannel.accept();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            channel.register(key.selector(),SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"客户端写入数据..."</span>);</span><br><span class="line">            key.interestOps(key.interestOps() &amp; (~SelectionKey.OP_READ));</span><br><span class="line">            pool.execute(<span class="keyword">new</span> ThreadHandleChannel(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadHandleChannel</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadHandleChannel</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"读取客户端传入数据..."</span>);</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//分配内存</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            ByteOutputStream byteOutputStream = <span class="keyword">new</span> ByteOutputStream();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从通道读取数据</span></span><br><span class="line">                <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((size = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    byteOutputStream.write(buffer.array(),<span class="number">0</span>,size);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">byte</span>[] content = byteOutputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">                ByteBuffer writeBuffer = ByteBuffer.allocate(content.length);</span><br><span class="line">                writeBuffer.put(content);</span><br><span class="line">                writeBuffer.flip();</span><br><span class="line">                <span class="comment">//write data</span></span><br><span class="line">                socketChannel.write(writeBuffer);</span><br><span class="line">                <span class="keyword">if</span>(size == -<span class="number">1</span>)&#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                selectionKey.interestOps(selectionKey.interestOps() | SelectionKey.OP_READ);</span><br><span class="line">                selectionKey.selector().wakeup();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AIO（Async-IO）"><a href="#AIO（Async-IO）" class="headerlink" title="AIO（Async IO）"></a>AIO（Async IO）</h2><p>异步非阻塞,结果返回回调接口</p><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        AsynchronousChannelGroup channelGroup = AsynchronousChannelGroup.withCachedThreadPool(executorService,<span class="number">2</span>);</span><br><span class="line">        AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open(channelGroup);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">//此处非阻塞,执行完成后就干下一步，返回结果会调用CompletionHandler#completed来处理</span></span><br><span class="line">        serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel channel, Object attachment)</span> </span>&#123;</span><br><span class="line">                serverSocketChannel.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(channel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer allocate = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    channel.read(allocate, allocate, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            attachment.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(attachment.array(),<span class="number">0</span>,result));</span><br><span class="line">                            channel.write(ByteBuffer.wrap(<span class="string">"hello client"</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Netty是什么"><a href="#Netty是什么" class="headerlink" title="Netty是什么"></a>Netty是什么</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Netty是一款异步的事件驱动的网络应用程序框架，支持快速开发可维护的高性能的面向协议的服务器和客户端。Netty主要是对java的nio包进行的封装。本质是一个NIO框架，用于服务器通信相关的多种应用场景</p><blockquote><p><strong>事件驱动</strong>：例如 Client 端发送的是个连接操作或者读请求或者断开连接，Netty 服务端可以读这几种不同的事件做定制的处理</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>对 NIO 进行封装，开发者不需要关注 NIO 的底层原理，只需要调用 Netty 组件就能够完成工作。</p></li><li><p>对网络调用透明，从 Socket 建立 TCP 连接到网络异常的处理都做了包装。</p></li><li><p>对数据处理灵活， Netty 支持多种序列化框架，通过“ChannelHandler”机制，可以自定义“编/解码器”。</p></li><li><p>对性能调优友好，Netty 提供了线程池模式以及 Buffer 的重用机制（对象池化），不需要构建复杂的多线程模型和操作队列。</p></li></ul><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li>EventLoop：线程，负责处理IO 实践</li><li>EventLoopGroup：线程池，包含了多个NioEventLoop</li><li>Channel：类似 Socket 的抽象，提供了 Socket 的，read(),wirte()，flush（）等操作，可以通过 Channel 获取这个 Channel 绑定到的NioEventLoop</li></ul><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-27-083706.png" alt=""></p><ul><li>Bootstrap:客户端的引导类应用程序网络层配置提供容器</li><li>ServerBootstrap：服务端的引导类应用程序网络层配置提供容器</li><li>ChannelHandler:从应用开发者看来，ChannelHandler是最重要的组件，其中存放用来处理进站和出站数据的用户逻辑。ChannelHandler的方法被网络事件触发，ChannelHandler可以用于几乎任何类型的操作，如将数据从一种格式转换为另一种格式或处理抛出的异常。例如，其子接口ChannelInboundHandler，接受进站的事件和数据以便被用户定义的逻辑处理，或者当响应所连接的客户端时刷新ChannelInboundHandler的数据</li><li>ChannelPipeline：ChannelPipeline为ChannelHandler链提供了一个容器并定义了用于沿着链传播入站和出站事件流的API。当创建Channel时，会自动创建一个附属的ChannelPipeline<br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-27-083753.png" alt=""></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>统一的API，适用于不同的协议（阻塞和非阻塞）<br>基于灵活、可扩展的事件驱动模型<br>高度可定制的线程模型<br>可靠的无连接数据Socket支持（UDP）</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>更好的吞吐量，低延迟<br>更低的资源消耗<br>最少的内存复制</p><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>不再因过快、过慢或超负载连接导致OutOfMemoryError<br>不再有在高速网络环境下NIO读写频率不一致的问题</p><h3 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h3><p>完整的SSL/TLS和STARTTLS的支持<br>可用于受限环境下，如 Applet 和OSGI</p><h3 id="易用："><a href="#易用：" class="headerlink" title="易用："></a>易用：</h3><p>详实的Javadoc和大量的示例集</p><p>示例代码：<br>server<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer(<span class="number">8888</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="comment">//创建EventLoopGroup，处理事件</span></span><br><span class="line">        EventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(boss,worker)</span><br><span class="line">                    <span class="comment">//指定所使用的NIO传输 Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//使用指定的端口设置套接字地址</span></span><br><span class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">                    <span class="comment">//添加一个EchoServerHandler到子Channel的ChannelPipeline</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//EchoServerHandler标志为@Shareable,所以我们可以总是使用同样的实例</span></span><br><span class="line">                            socketChannel.pipeline().addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//异步的绑定服务器，调用sync()方法阻塞等待直到绑定完成</span></span><br><span class="line">            ChannelFuture future = b.bind().sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭EventLoopGroup,释放所有的资源</span></span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">            worker.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable <span class="comment">//标识一个 ChannelHandler可以被多个Channel安全地共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buffer = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">//将消息记录到控制台</span></span><br><span class="line">        System.out.println(<span class="string">"Server received: "</span> + buffer.toString(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">//将接受到消息回写给发送者</span></span><br><span class="line">        ctx.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">hbv        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">                .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//打印异常栈跟踪</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        <span class="comment">//关闭该Channel</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = b.connect().sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoClient(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client received: "</span>+byteBuf.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty rocks"</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Netty能够做什么"><a href="#Netty能够做什么" class="headerlink" title="Netty能够做什么"></a>Netty能够做什么</h1><ul><li>远程服务调用，高性能网络通信如 Dubbo</li><li>开发异步、非阻塞的 TCP 网络应用程序；</li><li>开发异步、非阻塞的 UDP 网络应用程序；</li><li>Flink，Cassandra，Spark 等</li><li>开发异步文件传输应用程序；</li><li>开发异步 HTTP 服务端和客户端应用程序；</li><li>提供对多种编解码框架的集成，包括谷歌的 Protobuf、Jbossmarshalling、Java 序列化、压缩编解码、XML 解码、字符串编解码等，这些编解码框架可以被用户直接使用；</li><li>提供形式多样的编解码基础类库，可以非常方便的实现私有协议栈编解码框架的二次定制和开发；</li><li>基于职责链模式的 Pipeline-Handler 机制，用户可以非常方便的对网络事件进行拦截和定制；</li><li>所有的 IO 操作都是异步的，用户可以通过 Future-Listener 机制主动 Get 结果或者由 IO 线程操作完成之后主动 Notify 结果，用户的业务线程不需要同步等待</li><li>IP 黑白名单控制；</li><li>打印消息码流；</li><li>流量控制和整形；</li><li>性能统计；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在介绍 Netty之前一定要先搞明白同步和异步、阻塞和非阻塞、BIO、NIO、AIO 都是什么，然后有哪些优缺点，再来看 Netty 出现的
      
    
    </summary>
    
    
    
      <category term="Netty,NIO" scheme="https://yefan813.github.io/tags/Netty-NIO/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个短链接服务 </title>
    <link href="https://yefan813.github.io/2020/03/23/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1/"/>
    <id>https://yefan813.github.io/2020/03/23/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-03-23T10:29:02.000Z</published>
    <updated>2020-03-24T09:39:41.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现一个短连接服务"><a href="#实现一个短连接服务" class="headerlink" title="实现一个短连接服务"></a>实现一个短连接服务</h1><table><thead><tr><th style="text-align:left">所用技术</th><th style="text-align:left">功能</th><th style="text-align:left">完成度</th></tr></thead><tbody><tr><td style="text-align:left">Spring Boot</td><td style="text-align:left">框架</td><td style="text-align:left">已完成</td></tr><tr><td style="text-align:left">MySQL</td><td style="text-align:left">数据存储</td><td style="text-align:left">已完成</td></tr><tr><td style="text-align:left">Redis</td><td style="text-align:left">二级缓存</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">OpenResty</td><td style="text-align:left">代理 + 一级缓存</td><td style="text-align:left">已完成</td></tr><tr><td style="text-align:left">EhCache</td><td style="text-align:left">三级缓存</td><td style="text-align:left">已完成</td></tr><tr><td style="text-align:left">Zookeeper</td><td style="text-align:left">分布式锁</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">布隆过滤器</td><td style="text-align:left">判断hash是否存在</td><td style="text-align:left">已完成</td></tr></tbody></table><p><a href="https://github.com/yefan813/short-url.git" target="_blank" rel="noopener">代码地址</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>短链接好处</li><li>短链跳转的原理</li><li>锻炼生成的几种方式</li></ul><h2 id="短链接好处"><a href="#短链接好处" class="headerlink" title="短链接好处"></a>短链接好处</h2><p><img src="https://img2018.cnblogs.com/blog/725429/201911/725429-20191109192512207-1372819004.png" alt=""></p><h3 id="为啥要使用短链接"><a href="#为啥要使用短链接" class="headerlink" title="为啥要使用短链接"></a>为啥要使用短链接</h3><ul><li>大家可能都收到过这样的推广短信，点击上面链接后会跳转到指定的地址，大家有没想过别后的实现细节</li><li>我们经常需要将链接转成二维码的形式分享给他人，如果是长链的话二维码密集难识别，短链就不存在这个问题了,如图示</li><li>链接太长在有些平台上无法自动识别为超链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">原始网址：https://yefan813.github.io/</span><br><span class="line">短网址：http://xxxx.cn/Vvux2</span><br></pre></td></tr></table></figure><p>大家可能都收到过这样的推广短信，点击上面链接后会跳转到指定的地址，大家有没想过背后的实现细节</p><h2 id="短链跳转的原理"><a href="#短链跳转的原理" class="headerlink" title="短链跳转的原理"></a>短链跳转的原理</h2><p> 我们可以从这些短链接请求看下原理<br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-23-103507.png" alt=""><br>我们可以看到请求的http状态码是 302（重定向） 和 Location值具体跳转目标地址，浏览器拿到了得到这个长链接，发起重定向请求到目标地址</p><p>整体交互流程如下<br><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-23-103324.png" alt=""></p><p>这里有个问题http状态码, 301和302 有什么区别</p><ul><li>301: 代表 永久重定向，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301</li><li>302: 代表 临时重定向，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302</li></ul><h2 id="短链接生成的几种方式"><a href="#短链接生成的几种方式" class="headerlink" title="短链接生成的几种方式"></a>短链接生成的几种方式</h2><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-24-062346.png" alt=""></p><p>通过观察发现上面提到的短链接能发现，它是由固定的短链接域名 + 长链接映射成的一串字母组成，那么长链接怎么才能映射成一串字母呢？</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>  哈希算法非常多，我们如何选择呢？ 很多人可能会想到MD5, SHA等算法，但是我们选择 hash 算法的时候需要考虑的，生成的性能，<br>和产生冲突的概率。我们不回去考虑反向解码的性能或者难度，因为我们之直接将生成的 hash 字符串和长链接映射，不需反向生成。</p><p>  我们项目中使用Google 出品的 MurmurHash 算法，MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash 的随机分布特征表现更良好</p><p>  非加密意味着着相比 MD5，SHA 这些函数它的性能肯定更高（实际上性能是 MD5 等加密算法的十倍以上），也正是由于它的这些优点，所以虽然它出现于 2008，但目前已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中</p><p>  MurmurHash 提供了两种长度的哈希值，32 bit，128 bit，为了让网址尽可通地短，我们选择 32 bit 的哈希值，32 bit 能表示的最大值近 43 亿，对于中小型公司的业务而言绰绰有余。</p><p>  对长链(<a href="https://yefan813.github.io/)做">https://yefan813.github.io/)做</a> MurmurHash 计算，得到的哈希值为 849756688，于是我们现在得到的短链为 固定短链域名+哈希值 = <a href="http://xxxx.cn/849756688" target="_blank" rel="noopener">http://xxxx.cn/849756688</a></p><h4 id="1-如何让短网址更短？"><a href="#1-如何让短网址更短？" class="headerlink" title="1.如何让短网址更短？"></a>1.如何让短网址更短？</h4><p>  不过，你可能已经看出来了，通过 MurmurHash 算法得到的短网址还是很长啊，而且跟我们开头那个网址的格式好像也不一样。别着急，我们只需要稍微改变一个哈希值的表示方法，就可以轻松把短网址变得更短些。</p><p>  我们可以将 10 进制的哈希值，转化成更高进制的哈希值，这样哈希值就变短了。我们知道，16 进制中，我们用 A～E，来表示 10～15。在网址 URL 中，常用的合法字符有 0～9、a～z、A～Z 这样 62 个字符。为了让哈希值表示起来尽可能短，我们可以将 10 进制的哈希值转化成 62 进制。具体的计算过程，我写在这里了。最终用 62 进制表示的短网址就是<br>  <img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-24-062239.png" alt=""></p><h3 id="2-如何解决哈希冲突"><a href="#2-如何解决哈希冲突" class="headerlink" title="2.如何解决哈希冲突"></a>2.如何解决哈希冲突</h3><p>  解决思路，根据长链接生成hash字符串，然后去查找数据库会出现以下几种情况</p><ol><li>数据库不存在：这时候直接插入字符串和对应的长链接即可。</li><li>数据库存在：对应的长链接一样，这时说明其他人已经将次长链接生成了对应的短链接，这时候直接返回即可。</li><li>数据库存在：对应的长链接不一样，则说明冲突了，此时可以将长链接尾部，拼接一串特殊字符，比如“[DUPLICATED]”，然后跟再重新计算哈希值，两次哈希计算都冲突的概率，显然是非常低的。假设出现非常极端的情况，又发生冲突了，我们可以再拼接字符串，再计算哈希值。然后把计算得到的哈希值，跟原始网址拼接了特殊字符串之后的文本，一并存储在 MySQL 数据库中</li></ol><h3 id="压测一下看看性能"><a href="#压测一下看看性能" class="headerlink" title="压测一下看看性能"></a>压测一下看看性能</h3><p>其实这里没有做任何的缓存，所以请求全部落到数据库，很容易就能想到不能支持高并发，但还是压测一下装个 X</p><blockquote><p>100线程 并发执行生成短链接接口</p></blockquote><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-23-134741.png" alt=""></p><blockquote><p>短链接跳转接口结果和上面差不多</p></blockquote><h3 id="短链接跳转需要查询数据库，这时候其实可以将查询到的数据放入到本地缓存（三级缓存）还可以放入到-redis（二级缓存）-，也可以放入到-Nginx（一级缓存）"><a href="#短链接跳转需要查询数据库，这时候其实可以将查询到的数据放入到本地缓存（三级缓存）还可以放入到-redis（二级缓存）-，也可以放入到-Nginx（一级缓存）" class="headerlink" title="短链接跳转需要查询数据库，这时候其实可以将查询到的数据放入到本地缓存（三级缓存）还可以放入到 redis（二级缓存） ，也可以放入到 Nginx（一级缓存）"></a>短链接跳转需要查询数据库，这时候其实可以将查询到的数据放入到本地缓存（三级缓存）还可以放入到 redis（二级缓存） ，也可以放入到 Nginx（一级缓存）</h3><h4 id="加入本地缓存-Ehcache"><a href="#加入本地缓存-Ehcache" class="headerlink" title="加入本地缓存 Ehcache"></a>加入本地缓存 Ehcache</h4><blockquote><p>服务使用 Ehcache 后，压测短链接跳转结果</p></blockquote><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-23-164034.png" alt=""></p><h4 id="加入-Redis-缓存"><a href="#加入-Redis-缓存" class="headerlink" title="加入 Redis 缓存"></a>加入 Redis 缓存</h4><p>TODO</p><h4 id="加入-OpenResty"><a href="#加入-OpenResty" class="headerlink" title="加入 OpenResty"></a>加入 OpenResty</h4><p>TODO</p><h3 id="3-如何优化哈希算法生成短连接的性能"><a href="#3-如何优化哈希算法生成短连接的性能" class="headerlink" title="3.如何优化哈希算法生成短连接的性能"></a>3.如何优化哈希算法生成短连接的性能</h3><p>TODO</p><h2 id="利用-ID-生成器生成短链接"><a href="#利用-ID-生成器生成短链接" class="headerlink" title="利用 ID 生成器生成短链接"></a>利用 ID 生成器生成短链接</h2><p>TODO</p><h2 id="阶段一：实现一个简单的短连接服务"><a href="#阶段一：实现一个简单的短连接服务" class="headerlink" title="阶段一：实现一个简单的短连接服务"></a>阶段一：实现一个简单的短连接服务</h2><ol><li>根据URL生成短连接</li><li>实现短连接的跳转</li></ol><p>问题：</p><ol><li>如何解决Hash冲突问题</li><li>如何支持高性能短连接结构设计，例如：如何支持大量的并发生成短连接请求</li></ol><h2 id="阶段二：实现一个高性能的短链接服务器"><a href="#阶段二：实现一个高性能的短链接服务器" class="headerlink" title="阶段二：实现一个高性能的短链接服务器"></a>阶段二：实现一个高性能的短链接服务器</h2><ol><li>支持大并发访问生成短链接</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实现一个短连接服务&quot;&gt;&lt;a href=&quot;#实现一个短连接服务&quot; class=&quot;headerlink&quot; title=&quot;实现一个短连接服务&quot;&gt;&lt;/a&gt;实现一个短连接服务&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:le
      
    
    </summary>
    
    
    
      <category term="短链接,短网址,302,Spring Boot,Redis" scheme="https://yefan813.github.io/tags/%E7%9F%AD%E9%93%BE%E6%8E%A5-%E7%9F%AD%E7%BD%91%E5%9D%80-302-Spring-Boot-Redis/"/>
    
  </entry>
  
  <entry>
    <title>数据库，缓存一致性方案</title>
    <link href="https://yefan813.github.io/2020/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/"/>
    <id>https://yefan813.github.io/2020/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/</id>
    <published>2020-03-21T14:54:39.000Z</published>
    <updated>2020-03-21T14:55:46.941Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yefan813/eshop-inventory.git" target="_blank" rel="noopener">代码地址</a></p><p><strong>问题1</strong>：如果是先修改数据库，再删除缓存，如果删除缓存失败，那么会导致数据库中的数据是新数据，缓存中的是旧数据<br>，数据不一致。</p><p><strong>解决思路</strong>：先删除缓存，再修改数据库，如果删除缓存成功了，修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中</p><h1 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h1><ul><li><p>读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应</p></li><li><p>更新的时候，先删除缓存，然后再更新数据库</p></li></ul><h1 id="为什么是删除缓存，而不是更新缓存"><a href="#为什么是删除缓存，而不是更新缓存" class="headerlink" title="为什么是删除缓存，而不是更新缓存"></a>为什么是删除缓存，而不是更新缓存</h1><p>1，因为很多时候缓存不是直接数据库直接取出来的值，很可能做了逻辑运算以后再存入数据库<br>如果这类的数据要更新，则需要将相关的数据都查出来再去计算更新，这样代价太高了。</p><p>2，如果你频繁修改一个缓存涉及的多个表，那么这个缓存会被频繁的更新，频繁的更新缓存，但是问题在于，这个缓存到底会不会被频繁访问到？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">举个例子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次，100 次; 但是这个缓存在 1 分钟内就被读取了 1 次，有大量的冷数据</span><br><span class="line"></span><br><span class="line">热冷数据的 28 黄金法则：20% 的数据，占用了 80% 的访问量</span><br><span class="line"></span><br><span class="line">实际上，如果你只是删除缓存的话，那么 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低</span><br><span class="line"></span><br><span class="line">每次数据过来，就只是删除缓存，然后修改数据库，如果这个缓存，在 1 分钟内只是被访问了 1 次，那么只有那 1 次缓存是要被重新计算的，用缓存才去算缓存</span><br></pre></td></tr></table></figure><blockquote><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算<br>mybatis、hibernate 就是懒加载思想</p></blockquote><p><strong>问题2</strong>：一个比较复杂的数据不一致问题<br>1，数据发生了变更，先删除缓存，然后要去修改数据库，此时还没修改<br>2，一个并发请求过来，去读缓存，发现缓存空了，然后去查询数据库，查到了修改前的值，放到缓存<br>这时候出现数据库和缓存不一致。</p><p><strong><em>解决思路</em></strong>： 导致这种情况出现的原因是读写并发请求造成的，根据某个规则比如商品 ID 相同的请求路由到一台服务器上，可以尝试将读请求和更新请求进行串行化处理,</p><p><img src="http://test-pic-yefan.oss-cn-beijing.aliyuncs.com/2020-03-21-143455.png" alt=""></p><p><strong><em>具体流程如下</em></strong>：</p><ul><br><li>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部的队列中</li><br><li>读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据 + 更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部的队列中</li><br><li>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行</li><br></ul><p>这样的话，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新<br>此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成<br>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中<br>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回;<br>如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值</p><h3 id="需要优化的点"><a href="#需要优化的点" class="headerlink" title="需要优化的点"></a>需要优化的点</h3><p>1，一个队列中已经存在一个更新操作 + 一个读取操作，则后续的读请求可以尝试等待一段时间从缓存读取，因为前面的更新会删除缓存，后面的读取请求会将<br>再次放入到缓存中，后续的读请求可以尝试等待一段时间从缓存读取，如果等待时间过了再尝试从数据库去拿</p><h2 id="此方案的风险点"><a href="#此方案的风险点" class="headerlink" title="此方案的风险点"></a><b style="color:red">此方案的风险点</b></h2><p>1，可能 数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。所以务必通过一些模拟真实的测试，看看更新数据的频繁是怎样的</p><p>2,因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作</p><p>3, 会存在热点数据都打到同一台机器上的，可能造成某台机器压力过大的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/yefan813/eshop-inventory.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题1&lt;/strong&gt;：如果是先修改数据库，再
      
    
    </summary>
    
    
    
      <category term="Mysql,Redis" scheme="https://yefan813.github.io/tags/Mysql-Redis/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo和Spring Cloud优缺点</title>
    <link href="https://yefan813.github.io/2020/03/13/Dubbo%E5%92%8CSpring-Cloud%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>https://yefan813.github.io/2020/03/13/Dubbo%E5%92%8CSpring-Cloud%E4%BC%98%E7%BC%BA%E7%82%B9/</id>
    <published>2020-03-13T08:36:33.000Z</published>
    <updated>2020-03-13T08:40:31.924Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcse3kp0nvj30wj0u0wko.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gcse3kp0nvj30wj0u0wko.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Dubbo, Spring Boot" scheme="https://yefan813.github.io/tags/Dubbo-Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot自定义starter</title>
    <link href="https://yefan813.github.io/2020/03/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <id>https://yefan813.github.io/2020/03/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</id>
    <published>2020-03-06T12:52:13.000Z</published>
    <updated>2020-03-08T14:57:32.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot已经为很多的开源项目提供了很多的 starter项目，你也可以开发你自定义的 starter。再开始之前让我们先理解下Spring Boot是如何自动配置的，如果你已经知道 Spring Boot自动配置的过程可以直接调到创建自定义starter步骤。</p><h2 id="Spring-Boot-自动配置"><a href="#Spring-Boot-自动配置" class="headerlink" title="Spring Boot 自动配置"></a>Spring Boot 自动配置</h2><p>当你启动 Spring Boot 应用的时候，Spring Boot 会检测一个特殊的文件，它是 spring-boot-autoconfigure 这个包内的META-INF/spring.factories</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gckiuxcwefj30pk09q402.jpg" alt=""></p><p>它里面的内容我们重点关注这里<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gckivm3o4hj31500qq7d6.jpg" alt=""></p><p>这里是利用的spring SPI提供的扩展机制。</p><p>这里简单介绍下 SPI （全称Service Provider Interface），是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 SPI的作用就是为这些被扩展的API寻找服务实现。</p><p>通俗一点讲就是SPI 就是服务方提供接口，具体的实现由其他方来实现，只需要将实现了的类全路径加入到文件中，服务方启动的时候就会把这些文件内容解析出来，由于配置了类全路径地址，直接利用反射机制将这些类初始化提供使用。</p><h2 id="开始创建自定义的starter"><a href="#开始创建自定义的starter" class="headerlink" title="开始创建自定义的starter"></a>开始创建自定义的starter</h2><ul><li>创建一个Spring Boot 项目，在pom.xml中引入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建一个类 。该类starter 引入后自动加入到 Spring 容器中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class HelloService &#123;</span><br><span class="line">    private String prefix;</span><br><span class="line">    private String suffix;</span><br><span class="line">    </span><br><span class="line">    public HelloService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public HelloService(String prefix, String suffix) &#123;</span><br><span class="line">        this.prefix = prefix;</span><br><span class="line">        this.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello(String word) &#123;</span><br><span class="line">        return prefix + word + suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个配置类，提供 starter 引入方自定义属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//prefix = &quot;hello&quot; 引入 starter 的项目配置文件的前置是 hello</span><br><span class="line">@ConfigurationProperties(prefix = &quot;hello&quot;)</span><br><span class="line">public class HelloProperties &#123;</span><br><span class="line">    private String prefix;</span><br><span class="line">    private String suffix;</span><br><span class="line"></span><br><span class="line">    public String getPrefix() &#123;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrefix(String prefix) &#123;</span><br><span class="line">        this.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSuffix() &#123;</span><br><span class="line">        return suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSuffix(String suffix) &#123;</span><br><span class="line">        this.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建自动配置类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Configuration 定义当前类是个配置类</span><br><span class="line"> * @ConditionalOnClass，当classpath下发现该类（HelloService）的情况下进行自动配置。</span><br><span class="line"> * @ConditionalOnMissingBean，当Spring Context中不存在该Bean时。</span><br><span class="line"> * @ConditionalOnProperty(prefix = &quot;example.service&quot;,value = &quot;enabled&quot;,havingValue = &quot;true&quot;)，</span><br><span class="line"> * 当配置文件中example.service.enabled=true时将这个类创建为一个 Spring Bean</span><br><span class="line"> * @EnableConfigurationProperties(HelloProperties.class) 让使用 @ConfigurationProperties 注解的类生效</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(HelloService.class)</span><br><span class="line">@EnableConfigurationProperties(HelloProperties.class)</span><br><span class="line">public class HelloAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    @ConditionalOnProperty(prefix = &quot;hello&quot;, value = &quot;enable&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">    HelloService helloService() &#123;</span><br><span class="line">        return new HelloService(helloProperties.getPrefix(),helloProperties.getSuffix());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在/resources/META-INF/spring.factories 创建这个文件<br>文件写入内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.yefan.hello.HelloAutoConfiguration</span><br></pre></td></tr></table></figure><ul><li>mvn install 将项目安装到本地仓库</li></ul><hr><ul><li>创建另外一个Spring Boot 项目，像引入其他 starter 方式引入上面创建的 maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yefan.study<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在application.yml中配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello:</span><br><span class="line">  enable: true</span><br><span class="line">  prefix: xxx</span><br><span class="line">  suffix: xxx</span><br></pre></td></tr></table></figure><ul><li>注入 HelloService 即可使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">HelloService helloService;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Spring Boot已经为很多的开源项目提供了很多的 starter项目，你也可以开发你自定义的 starter。再开始之前让我们先理解下
      
    
    </summary>
    
    
    
      <category term="spring boot starter" scheme="https://yefan813.github.io/tags/spring-boot-starter/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Bean的生命周期</title>
    <link href="https://yefan813.github.io/2020/03/05/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://yefan813.github.io/2020/03/05/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-03-05T12:15:25.000Z</published>
    <updated>2020-03-05T12:37:18.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-中-Bean-的生命周期图"><a href="#Spring-中-Bean-的生命周期图" class="headerlink" title="Spring 中 Bean 的生命周期图"></a>Spring 中 Bean 的生命周期图</h1><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcjbq7e3q8j30n8123agj.jpg" alt=""></p><p><a href="https://github.com/yefan813/spring-bean-life-cycle" target="_blank" rel="noopener">源码地址</a><br>项目中每个类的作用在上图中都写得非常清楚，可以下载下载直接运行看下整体效果，最好能 Debug 一下看下详细的流程。</p><p>###参考文献：<br><a href="https://www.cnblogs.com/xrq730/p/5721366.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/5721366.html</a><br><a href="https://blog.csdn.net/caihaijiang/article/details/35552859" target="_blank" rel="noopener">https://blog.csdn.net/caihaijiang/article/details/35552859</a><br><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-中-Bean-的生命周期图&quot;&gt;&lt;a href=&quot;#Spring-中-Bean-的生命周期图&quot; class=&quot;headerlink&quot; title=&quot;Spring 中 Bean 的生命周期图&quot;&gt;&lt;/a&gt;Spring 中 Bean 的生命周期图&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>chrome模拟跨域访问</title>
    <link href="https://yefan813.github.io/2020/02/11/chrome%E6%A8%A1%E6%8B%9F%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/"/>
    <id>https://yefan813.github.io/2020/02/11/chrome%E6%A8%A1%E6%8B%9F%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/</id>
    <published>2020-02-11T06:33:53.000Z</published>
    <updated>2020-02-11T06:37:31.666Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>首先随便打开一个网站</p></li><li><p>打开 console<br>输入</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var data = &#123;</span><br><span class="line">  password: &quot;xxx&quot;,</span><br><span class="line">  userName: &quot;xxx&quot;</span><br><span class="line">&#125;; </span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;post&apos;, &apos;http://127.0.0.1:8080/console/login&apos;);  </span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/json&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;SESSION_TOKEN&quot;,&quot;112233&quot;);</span><br><span class="line">xhr.setRequestHeader(&quot;CONSOLE_SESSION_TOKEN&quot;,&quot;112233&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xhr.send(JSON.stringify(data));</span><br><span class="line">xhr.onload = function(e) &#123;</span><br><span class="line">    var xhr = e.target;</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改域名、参数、header等信息即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先随便打开一个网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开 console&lt;br&gt;输入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mybatis 常见面试问题及答案</title>
    <link href="https://yefan813.github.io/2019/10/31/mybatis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>https://yefan813.github.io/2019/10/31/mybatis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</id>
    <published>2019-10-31T12:56:23.000Z</published>
    <updated>2019-12-13T09:23:25.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis面试连环炮"><a href="#Mybatis面试连环炮" class="headerlink" title="Mybatis面试连环炮"></a>Mybatis面试连环炮</h2><p>先抛出几个问题，然后带着问题一起看下 <a href="https://mybatis.org/mybatis-3/" target="_blank" rel="noopener">Mybatis官网</a>如何解释这个问题。</p><h3 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis?"></a><em>什么是Mybatis?</em></h3><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><a id="more"></a><hr><h3 id="Mybaits的优点"><a href="#Mybaits的优点" class="headerlink" title="Mybaits的优点"></a><em>Mybaits的优点</em></h3><blockquote></blockquote><ol><li>门槛低易上手</li><li>sql 可以统一写到 xml 统一管理</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写动态sql。</li></ol><hr><h3 id="Mybaits的缺点"><a href="#Mybaits的缺点" class="headerlink" title="Mybaits的缺点"></a><em>Mybaits的缺点</em></h3><blockquote></blockquote><ol><li>sql依赖于数据库，导致数据库移植性差。</li><li>缓存使用不当，容易产生脏数据。</li></ol><hr><h3 id="Mybatis全局配置文件中有哪些标签-分别代表什么意思"><a href="#Mybatis全局配置文件中有哪些标签-分别代表什么意思" class="headerlink" title="Mybatis全局配置文件中有哪些标签?分别代表什么意思?"></a><em>Mybatis全局配置文件中有哪些标签?分别代表什么意思?</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hg3nx33uj30fe0b4gnl.jpg" alt=""></p></blockquote><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hg2p0aw2j30a607wmxx.jpg" alt=""></p></blockquote><hr><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a><em>#{}和${}的区别是什么？</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hix8i6caj317t0ihgql.jpg" alt=""></p></blockquote><hr><h3 id="Mybatis-映射器引用资源方式有几种"><a href="#Mybatis-映射器引用资源方式有几种" class="headerlink" title="Mybatis 映射器引用资源方式有几种"></a>Mybatis 映射器引用资源方式有几种</h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hhyiasmvj31810jzq7i.jpg" alt=""></p></blockquote><hr><h3 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a><em>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</em></h3><p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt; </span><br><span class="line">   select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;; </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>第2种： 通过<resultmap>来映射字段名和实体类属性名的一一对应的关系</resultmap></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderresultmap&quot;&gt;</span><br><span class="line">       select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line">  &lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt; </span><br><span class="line">       &lt;!–用id属性来映射主键字段–&gt; </span><br><span class="line">       &lt;id property=”id” column=”order_id”&gt; </span><br><span class="line">       &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt; </span><br><span class="line">       &lt;result property = “orderno” column =”order_no”/&gt; </span><br><span class="line">       &lt;result property=”price” column=”order_price” /&gt; </span><br><span class="line">   &lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a><em>如何获取自动生成的(主)键值?</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hjvaw3isj31880jsjwn.jpg" alt=""></p></blockquote><hr><h3 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？"></a><em>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？</em></h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hjxub3t9j318a0qiafh.jpg" alt=""></p></blockquote><blockquote><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p></blockquote><p><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">传送门</a></p><hr><h3 id="Mybatis-几个关键类对象的作用域-Scope-和生命周期"><a href="#Mybatis-几个关键类对象的作用域-Scope-和生命周期" class="headerlink" title="Mybatis 几个关键类对象的作用域(Scope)和生命周期"></a>Mybatis 几个关键类对象的作用域(Scope)和生命周期</h3><blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hg0t1yxvj317r0mqtg4.jpg" alt=""></p></blockquote><h3 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a><em>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</em></h3><blockquote><p>这是来自 Mybatis 官网一段描述<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hfm140fmj318903a3zi.jpg" alt=""><br>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。<br>如下：<br><code>&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;</code></p></blockquote><hr><h3 id="通常一个Xml映射文件，都会写一个Dao-Mapper-接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#通常一个Xml映射文件，都会写一个Dao-Mapper-接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao(Mapper)接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a><em>通常一个Xml映射文件，都会写一个Dao(Mapper)接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</em></h3><blockquote><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。</p></blockquote><blockquote><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement</p></blockquote><blockquote><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p></blockquote><p><code>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</code></p><hr><h3 id="接口绑定有几种实现方式-分别是怎么实现的"><a href="#接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="接口绑定有几种实现方式,分别是怎么实现的?"></a><em>接口绑定有几种实现方式,分别是怎么实现的?</em></h3><blockquote><ol><li>一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定</li><li>另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.</li></ol></blockquote><hr><h3 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a><em>Mybatis是如何进行分页的？分页插件的原理是什么？</em></h3><blockquote><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p></blockquote><blockquote><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p></blockquote><hr><h3 id="简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件"></a><em>简述Mybatis的插件运行原理，以及如何编写一个插件</em></h3><blockquote><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p></blockquote><blockquote><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnaapuy1j318q0ogn3c.jpg" alt=""></h2><h3 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a><em>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</em></h3><blockquote><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p></blockquote><blockquote><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p></blockquote><p><a href="https://www.cnblogs.com/ashleyboy/p/9286814.html" target="_blank" rel="noopener">延迟加载实例</a></p><hr><h3 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a><em>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</em></h3><blockquote><p>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</resultmap></p></blockquote><blockquote><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p></blockquote><hr><h3 id="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"><a href="#Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别" class="headerlink" title="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"></a><em>Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</em></h3><blockquote><p>能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p></blockquote><blockquote><p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p></blockquote><blockquote><p>那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是<resultmap>标签内的<id>子标签，指定了唯一确定一条记录的id列，Mybatis根据<id>列值来完成100条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。</id></id></id></resultmap></p></blockquote><blockquote><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnxze2t7j30p408naaw.jpg" alt=""></p><blockquote><p>官方 resultMap 文档：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hnyzjlfaj318g0jidlt.jpg" alt=""></p></blockquote><hr><h3 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a><em>Mybatis是否可以映射Enum枚举类？</em></h3><p>可以<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8hgj8d3icj318b0pltfz.jpg" alt=""></p><hr><h3 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a><em>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</em></h3><ol><li>SIMPLE 就是普通的执行器,每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象；</li><li>REUSE 执行器会重用预处理语句（prepared statements）,执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象</li><li>BATCH 执行器将重用语句并执行批量更新,执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ol><hr><h3 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a><em>Mybatis中如何指定使用哪一种Executor执行器？</em></h3><p>在 Mybatis xml配置文件 <setting> 中设置defaultExecutorType<br><code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;</code></setting></p><hr><h3 id="如何执行批量插入"><a href="#如何执行批量插入" class="headerlink" title="如何执行批量插入?"></a><em>如何执行批量插入?</em></h3><blockquote><ol><li><p>在 mapper.xml文件中使用<foreach></foreach></p></li><li><p>SqlSessionFactory sqlSessionFactory=getSqlSessionFactory();</p><pre><code>//可以执行批量操作的sqlSessionSqlSession openSession=sqlSessionFactory.openSession(ExecutorType.BATCH);</code></pre></li></ol></blockquote><hr><h3 id="说一下resultMap和resultType的区别"><a href="#说一下resultMap和resultType的区别" class="headerlink" title="说一下resultMap和resultType的区别"></a><em>说一下resultMap和resultType的区别</em></h3><p><strong>resultType：</strong>    从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。</p><p><strong>resultMap：</strong>    外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂映射的情形都能迎刃而解。可以使用 resultMap 或 resultType，但不能同时使用。</p><hr><h3 id="什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存"><a href="#什么是Mybatis的一级、二级缓存-如何开启-什么样的数据适合缓存" class="headerlink" title="什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?"></a><em>什么是Mybatis的一级、二级缓存,如何开启?什么样的数据适合缓存?</em></h3><blockquote><ol><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li></ol></blockquote><blockquote><ol><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></li></ol></blockquote><blockquote><ol><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ol></blockquote><hr><h3 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a><em>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</em></h3><blockquote><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p></blockquote><blockquote><p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mybatis面试连环炮&quot;&gt;&lt;a href=&quot;#Mybatis面试连环炮&quot; class=&quot;headerlink&quot; title=&quot;Mybatis面试连环炮&quot;&gt;&lt;/a&gt;Mybatis面试连环炮&lt;/h2&gt;&lt;p&gt;先抛出几个问题，然后带着问题一起看下 &lt;a href=&quot;https://mybatis.org/mybatis-3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mybatis官网&lt;/a&gt;如何解释这个问题。&lt;/p&gt;
&lt;h3 id=&quot;什么是Mybatis&quot;&gt;&lt;a href=&quot;#什么是Mybatis&quot; class=&quot;headerlink&quot; title=&quot;什么是Mybatis?&quot;&gt;&lt;/a&gt;&lt;em&gt;什么是Mybatis?&lt;/em&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="mybatis" scheme="https://yefan813.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>tcc-traction源码阅读笔记</title>
    <link href="https://yefan813.github.io/2019/10/24/tcc-traction%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://yefan813.github.io/2019/10/24/tcc-traction%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2019-10-23T16:06:56.000Z</published>
    <updated>2019-12-13T09:26:27.061Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/xie-summer/tcc-transaction-v1.1.5.git" target="_blank" rel="noopener">tcc-trancation 分布式事务框架源码阅读</a></p><p><a href="https://blog.csdn.net/dm_vincent/article/details/92432059" target="_blank" rel="noopener">TCC的异常场景及应对机制</a></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1&gt;com.roncoo.pay.service.trade.biz.impl.RpTradePaymentManagerBizImpl#completeSuccessOrder 银行返回订单支付成功，后调支付成功,还未执行方法，被拦截器拦截</span><br><span class="line"> 2&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#interceptCompensableMethod 进入可事务补偿拦截器</span><br><span class="line">3&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行者类型 MethodType.ROOT</span><br><span class="line"> 4&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#rootMethodProceed  主事务方法的处理</span><br><span class="line">  5&gt;org.mengyun.tcctransaction.TransactionManager#begin 事务开始（创建事务日志记录，并将该事务日志记录存入当前线程的事务局部变量中） TransactionType.ROOT</span><br><span class="line">   6&gt;org.aspectj.lang.ProceedingJoinPoint#proceed()   Try (开始执行被拦截的方法，或进入下一个拦截器处理逻辑) ，执行完毕等待返回....</span><br><span class="line"> 7&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#interceptTransactionContextMethod  资源拦截器，拦截事务上下文方法</span><br><span class="line">  8&gt;org.mengyun.tcctransaction.TransactionManager#getCurrentTransaction 获取当前事务，没有则新建事务（trying状态）</span><br><span class="line">   9&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行者类型（ROOT）</span><br><span class="line">    10&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#generateAndEnlistRootParticipant </span><br><span class="line">生成和登记根参与者Participant（Participant保存确认方法和确认方法的实例) 加入到参与者列表，更新事务信息（加入了事务参与者，包含了触发confirm或cancel方法的参数信息）</span><br><span class="line">      11&gt;org.aspectj.lang.ProceedingJoinPoint#proceed(java.lang.Object[]) 开始执行被拦截的方法，或进入下一个拦截器处理逻辑</span><br><span class="line">12&gt;com.roncoo.pay.service.trade.biz.impl.RpTradePaymentManagerBizImpl#completeSuccessOrder 真正进入到方法内部执行 修改支付记录状态， 修改支付订单状态</span><br><span class="line"> 13&gt;com.roncoo.pay.service.account.api.RpAccountTransactionService#creditToAccountTcc 调用给商户资金帐户加款（平台收款） try 方法，调用参与者账户资金系统加款，调用之前被拦截器拦截</span><br><span class="line"> 14&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#interceptTransactionContextMethod  获取当前事务，从当前线程 threadLocal 中可以获取到事务</span><br><span class="line">  15&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行者类型，MethodType.CONSUMER</span><br><span class="line">   16&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#generateAndEnlistConsumerParticipant 生成并登记消费者的参与者Participant</span><br><span class="line">   服务接口的 TransactionContext 参数设值（新的事务分支ID），状态为当前transaction状态TRYING ,构建事务confirm上下文和构建事务cancle上下文</span><br><span class="line">    17&gt;org.aspectj.lang.ProceedingJoinPoint#proceed(java.lang.Object[]) 继续执行 方法</span><br><span class="line">     18&gt; com.roncoo.pay.service.account.api.RpAccountTransactionService#creditToAccountTcc 回到方法执行 try 方法，发起远程调用</span><br><span class="line">      19&gt;com.roncoo.pay.service.account.aip.impl.RpAccountTransactionServiceImpl#creditToAccountTcc 到了资金账户系统 provider 方真正执行方法</span><br><span class="line">       20&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#interceptCompensableMethod 被可补偿事务拦截器拦截</span><br><span class="line">        21&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前执行方的类型，MethodType.PROVIDER</span><br><span class="line">         22&gt;org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor#providerMethodProceed 服务提供者事务方法处理. 当前分支事务状态为TRYING</span><br><span class="line">          基于全局事务ID扩展创建新的分支事务，并存于当前线程的事务局部变量中.</span><br><span class="line">          23&gt;org.aspectj.lang.ProceedingJoinPoint#proceed()开始执行被拦截的方法，或进入下一个拦截器处理逻辑</span><br><span class="line">           24&gt; org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#interceptTransactionContextMethod 进入到资源协调拦截器</span><br><span class="line">           25&gt;org.mengyun.tcctransaction.utils.CompensableMethodUtils#calculateMethodType 判断当前类型为PROVIDER</span><br><span class="line">            26&gt;org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor#generateAndEnlistProviderParticipant 生成并登记服务提供者的参与者 </span><br><span class="line">            构建确认方法的提交上下文，构建取消方法的提交上下文 加入参与者列表更新本地缓存</span><br><span class="line">             27&gt;org.aspectj.lang.ProceedingJoinPoint#proceed(java.lang.Object[]) 开始执行被拦截的方法，或进入下一个拦截器处理逻辑</span><br><span class="line">              28&gt;com.roncoo.pay.service.account.aip.impl.RpAccountTransactionServiceImpl#creditToAccountTcc 开始真正执行账户资金系统的 try 方法</span><br><span class="line">29&gt;com.roncoo.pay.service.trade.biz.impl.RpTradePaymentManagerBizImpl#completeSuccessOrder 账户资金加款成功，回到completeSuccessOrder方法继续执行</span><br><span class="line"> 30&gt;com.roncoo.pay.service.point.api.RpPointAccountService#creditToPointAccountTcc client调用被拦截  过程和 13 ~ 29 过程一样</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">   &gt;com.roncoo.pay.service.point.api.RpPointAccountService#creditToPointAccountTcc rpc 执行完毕返回</span><br><span class="line">    &gt; org.aspectj.lang.ProceedingJoinPoint#proceed()  执行完毕回到 步骤 6</span><br><span class="line">     &gt;org.mengyun.tcctransaction.TransactionManager#commit Try检验正常后提交（try 方法过程中如果出现异常或调用org.mengyun.tcctransaction.TransactionManager#rollback 火锅就是遍历事务参与者这列表中的 cancle 方法）(事务管理器在控制提交)：Confirm</span><br><span class="line">     &gt;org.mengyun.tcctransaction.Transaction#commit 遍历调用事务参与者列表的 commit 方法</span><br><span class="line">      &gt;org.mengyun.tcctransaction.Participant#commit</span><br><span class="line">      &gt;org.mengyun.tcctransaction.Terminator#invoke confirmInvocationContext 调用之前写入的 confirm 上线文直接执行各个参与者的 confirm 方法</span><br><span class="line">       &gt;org.mengyun.tcctransaction.TransactionRepository#delete confirm 完成后会调用事务删除方法删除日志，这里注意如果 confirm 失败了导致日志没有删除，会有个事务调度系统TransactionRecovery 定时的检索出为被删除的事务数据然后一直调用 confirm 方法去确认并记录重试次数（重试一定次数不在重试）。</span><br><span class="line">       所以接口一定要保持幂等才行 这里特别注意</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/xie-summer/tcc-transaction-v1.1.5.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tcc-trancation 分布式事务框架源码阅读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/dm_vincent/article/details/92432059&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCC的异常场景及应对机制&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java远程调试</title>
    <link href="https://yefan813.github.io/2019/10/11/java%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://yefan813.github.io/2019/10/11/java%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</id>
    <published>2019-10-11T10:29:05.000Z</published>
    <updated>2019-12-13T09:25:22.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-远程调试"><a href="#java-远程调试" class="headerlink" title="java 远程调试"></a>java 远程调试</h2><p>调试对于排查 java 各种异常问题非常重要，相信本地调试大家都很熟悉，今天分享一下如何开启远程调试。</p><ol><li><p>如果需要编译.java文件执行命令javac,生成.class文件件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac SynchronizedStudy.java</span><br></pre></td></tr></table></figure></li><li><p>执行编译过后的.class文件</p><ul><li><p>如果当前类有包路径到包的根路径下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java com.xxx.xx.SynchronizedStudy</span><br></pre></td></tr></table></figure></li><li><p>如果当前类没有包直接执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java SynchronizedStudy</span><br></pre></td></tr></table></figure></li></ul></li></ol><a id="more"></a><ol><li><p>如果要启动远程 debug 端口</p><ul><li><p>如果执行 java 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=5005 com.yefan.study.SynchronizedStudy</span><br></pre></td></tr></table></figure></li><li><p>如果执行 jar 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=5005 -jar SynchronizedStudy.jar</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>启动成功会显示如下</p><blockquote><p>Listening for transport dt_socket at address: 5005</p></blockquote><pre><code>### 远程调试命令参数说明**-Xdebug:** 启用调试特性。**-Xrunjdwp:** 在目标 VM 中加载 JDWP 实现。它通过传输和 JDWP 协议与独立的调试器应用程序通信。**transport:** 这里通常使用套接字传输。**server:** 如果值为 y，目标应用程序监听将要连接的调试器应用程序。否则，它将连接到特定地址上的调试器应用程序。**address:** 这是连接的传输地址。如果服务器为 n，将尝试连接到该地址上的调试器应用程序。否则，将在这个端口监听连接。**suspend:**如果值为 y，目标 VM 将暂停，直到调试器应用程序进行连接。如果值为 n，没有调试器连接则继续执行</code></pre><h2 id="IDEA远程调试配置"><a href="#IDEA远程调试配置" class="headerlink" title="IDEA远程调试配置"></a>IDEA远程调试配置</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7unzpdz6hj30gu11o452.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7unxw0y3oj31bj0u0n35.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java-远程调试&quot;&gt;&lt;a href=&quot;#java-远程调试&quot; class=&quot;headerlink&quot; title=&quot;java 远程调试&quot;&gt;&lt;/a&gt;java 远程调试&lt;/h2&gt;&lt;p&gt;调试对于排查 java 各种异常问题非常重要，相信本地调试大家都很熟悉，今天分享一下如何开启远程调试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果需要编译.java文件执行命令javac,生成.class文件件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;javac SynchronizedStudy.java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行编译过后的.class文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果当前类有包路径到包的根路径下执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java com.xxx.xx.SynchronizedStudy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果当前类没有包直接执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java SynchronizedStudy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="java javac javap 远程调试" scheme="https://yefan813.github.io/tags/java-javac-javap-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Filter 和 Interceptor 比较</title>
    <link href="https://yefan813.github.io/2018/07/31/filer-interceptor/"/>
    <id>https://yefan813.github.io/2018/07/31/filer-interceptor/</id>
    <published>2018-07-31T02:55:42.000Z</published>
    <updated>2018-08-31T07:21:10.108Z</updated>
    
    <content type="html"><![CDATA[<ol><li>过滤器（Filter）</li><li>拦截器（Interceptor</li></ol><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><ul><li><p>Filter是servlet规范中定义的java web组件, 在所有支持java web的容器中都可以使用</p></li><li><p>Filter和Filter Chain是密不可分的, Filter可以实现依次调用正是因为有了Filter Chain</p></li></ul><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ftsv1u5fihj30hh089abw.jpg" alt=""></p><p>上图是Filter对请求进行拦截的原理图, 那么java web容器(以tomcat为例子)是如何实现这个功能的呢?</p><p>下面看下Filter和Filter Chain的源码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Filter</span><br><span class="line">     public interface Filter &#123;</span><br><span class="line"></span><br><span class="line">         // 容器创建的时候调用, 即启动tomcat的时候调用</span><br><span class="line">         public void init(FilterConfig filterConfig) throws ServletException;</span><br><span class="line"></span><br><span class="line">         // 由FilterChain调用, 并且传入Filter Chain本身</span><br><span class="line">         public void doFilter(ServletRequest request, ServletResponse response,</span><br><span class="line">                 FilterChain chain) throws IOException, ServletException;</span><br><span class="line"></span><br><span class="line">         // 容器销毁的时候调用, 即关闭tomcat的时候调用</span><br><span class="line">         public void destroy();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // FilterChain</span><br><span class="line">     public interface FilterChain &#123;</span><br><span class="line"></span><br><span class="line">         // 由Filter.doFilter()中的chain.doFilter调用</span><br><span class="line">         public void doFilter(ServletRequest request, ServletResponse response)</span><br><span class="line">             throws IOException, ServletException;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li><p>正是因为Filter Chain在调用每一个Filter.doFilter()时将自身引用传递进去, 才实现了Filter的依次调用, 在Filter全部调用完之后再调用真正处理请求的servlet, 并且再次逆序回调Filter. 可能这么看还是不太明白是怎么实现Filter的顺序调用, 调用真正的servlet, 逆序调用Filter的, 一起看下Tomcat的源码就一目了然了.</p></li><li><p>在tomcat中Filter Chain的默认实现是ApplicationFilterChain, 在ApplicationFilterChain中最关键的方法就是internalDoFilter, 整个Filter流程的实现就是由这个方法完成.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// internalDoFilter(只保留关键代码)</span><br><span class="line">     private void internalDoFilter(ServletRequest request, ServletResponse response)</span><br><span class="line">         throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">         // Call the next filter if there is one</span><br><span class="line">         // pos: 当前的filter的索引, n: 调用链中所有的Filter的数量</span><br><span class="line">         // 如果调用链中还有没有调用的Filter就继续调用, 否则跳过if语句</span><br><span class="line">         if (pos &lt; n) &#123;</span><br><span class="line">             ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">             try &#123;</span><br><span class="line">                 // 获取Filter</span><br><span class="line">                 Filter filter = filterConfig.getFilter();</span><br><span class="line">                 if( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                     ...</span><br><span class="line">                     其他代码</span><br><span class="line">                     ...    </span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     // 这句话是重点, 调用Filter的doFilter方法并把Filter Chain本身传进去(this)</span><br><span class="line">                     filter.doFilter(request, response, this);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; catch (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">                 ...</span><br><span class="line">                 异常处理代码</span><br><span class="line">                 ...    </span><br><span class="line">             &#125;</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // We fell off the end of the chain -- call the servlet instance</span><br><span class="line">         try &#123;</span><br><span class="line">             ...</span><br><span class="line">             其他代码</span><br><span class="line">             ...</span><br><span class="line">             // Use potentially wrapped request from this point</span><br><span class="line">             if ((request instanceof HttpServletRequest) &amp;&amp;</span><br><span class="line">                     (response instanceof HttpServletResponse) &amp;&amp;</span><br><span class="line">                     Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                 ...</span><br><span class="line">                 其他代码</span><br><span class="line">                 ...</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                        // 调用真正的Filter</span><br><span class="line">                 servlet.service(request, response);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; catch (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">             ...</span><br><span class="line">             异常处理代码</span><br><span class="line">             ...</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">             ...</span><br><span class="line">             始终要执行的代码</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Filter的正序调用的过程和调用真正的servlet的过程了, 但是Filter的逆序调用在哪里体现了呢?</p></blockquote><ul><li>假设下面的Filter就是调用链中的最后一个Filter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">        public void doFilter(ServletRequest request, ServletResponse response,</span><br><span class="line">            FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        Log.info(&quot;before&quot;);</span><br><span class="line">             chain.doFilter(request, response);       </span><br><span class="line">            Log.info(&quot;after&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在调用chain.doFilter之后就跳过了if语句从而调用了真正的servlet, 然后internalDoFilter方法就结束(出栈)了, 紧接着就是调用Log.info(“after”)了, 然后LogFilter的doFilter就结束了(也出栈了), 紧接着就是internalDoFilter中filter.doFilter(request, response, this)的结束然后return, 然后就是调用上一个filter的chain.doFilter()之后的代码, 以此类推.</p><p>因此Filter调用链的实现其实就是一个方法调用链的过程. 刚开始, Filter Chain每调用一个Filter.doFilter()方法就是向方法调用栈中进行压栈操作(代码上的体现就是执行Filter.doFilter之前的代码), 当Filter全部调用完成之后就调用真正处理请求的servlet, 然后由方法调用链自动进行出栈操作(代码上的体现就是执行Filter.doFilter之后的代码), 从而完成整个Filter的调用链. 因为Filter功能实现实际上就是利用了方法的压栈出栈, 所以可以在调用chain.doFilter之前将方法返回, 让容器不在调用servlet方法, 从而实现权限的控制, 关键词的过滤等功能.</p><h1 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h1><ul><li>Interceptor不是servlet规范中的java web组件, 而是Spring提供的组件, 功能上和Filter差不多. 但是实现上和Filter不一样.</li></ul><p>Interceptor功能的实现主要是在Spring Mvc的DispatcherServelt.doDispatch方法中, 让我们来看看源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Interceptor的源码</span><br><span class="line">public interface HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    // 在调用真正的处理请求类之前调用</span><br><span class="line">    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line">    // 在调用真正的处理请求类之后调用</span><br><span class="line">    void postHandle(</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line"> // 在完成渲染或者出错之后调用</span><br><span class="line">    void afterCompletion(</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doDispatch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> doDispatch源码(只保留关键代码)</span><br><span class="line"></span><br><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ModelAndView mv = null;</span><br><span class="line">            Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ....</span><br><span class="line">                其它的处理代码</span><br><span class="line">                ....</span><br><span class="line"></span><br><span class="line">                // 调用拦截器的前置处理方法</span><br><span class="line">                if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Actually invoke the handler.</span><br><span class="line">                // 调用真正的处理请求的方法</span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                // 找到渲染模版</span><br><span class="line">                applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">                // 调用拦截器的后置处理方法</span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                ....</span><br><span class="line">                异常处理代码</span><br><span class="line">                ....</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            ....</span><br><span class="line">            始终要执行的代码</span><br><span class="line">            ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实看了doDispatch的关键代码, Spring Mvc对整个请求的处理流程已经很清楚了:</p><blockquote><p>调用拦截器的前置方法 -&gt; 调用处理请求的方法 -&gt; 渲染模版 -&gt; 调用拦截器的后置处理方法 -&gt; 调用拦截器的完成方法</p></blockquote><p>接下来看一看Spring Mvc是如何实现依次调用这么多拦截器的前置方法, 后置方法, 完成方法的。</p><p>进入到mapperHandler.applyPreHandle()方法中(调用拦截器的前置方法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        // 如果拦截器数组不为空</span><br><span class="line">        if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">           // 按顺序调用拦截器数组中的preHandle方法</span><br><span class="line">            for (int i = 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                // 如果拦截器的preHandle方法返回false, 则调用当前拦截器的triggerAfterCompletion方法, 然后返回, 并且不再调用后续的拦截器</span><br><span class="line">                if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">                    triggerAfterCompletion(request, response, null);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                this.interceptorIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入到mappedHandler.applyPostHandle()方法中(调用拦截器的后置方法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        // 如果拦截器数组不为空</span><br><span class="line">        if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            // 倒序调用拦截器数组中拦截器的postHandle方法</span><br><span class="line">            for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不管是否出异常triggerAfterCompletion方法始终会被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        // 拦截器数组不为空</span><br><span class="line">        if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">           // 从成功执行的最后一个拦截器开始“逆序”调用afterCompletion方法</span><br><span class="line">            for (int i = this.interceptorIndex; i &gt;= 0; i--) &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                try &#123;</span><br><span class="line">                    interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable ex2) &#123;</span><br><span class="line">                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注：triggerAfterCompletion会逆序调用afterCompletion方法</strong></p><p>看过以上三个方法之后, Spring Mvc如何处理拦截器的前置, 后置, 完成方法就一目了然了. 其实Spring Mvc就是将拦截器统一放到了拦截器数组中, 然后在调用真正的处理请求方法之前和之后正序或者倒序遍历拦截器, 同时调用拦截器的相应的方法. 最后不管是否正常结束这个流程还是出异常都会从成功的最后一个拦截器开始逆序调用afterCompletion方法</p><p>Filter 和 Inteceptor 调用流程<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ftsuzrys62j30mc0ct105.jpg" alt=""></p><p><img src="http://s2.51cto.com/wyfs02/M02/8B/3D/wKiom1hHhbmxseDtAACidU9Y84s787.png" alt=""></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li>从以上分析可以看到过滤器和拦截器实现的方式的不同. Filter是利用了方法的调用(入栈出栈)完成整个流程, 而Interceptor是利用了for循环完成了整个流程.</li><li>Filter的实现比较占用栈空间, 在Filter多的情况下可能会有栈溢出的风险存在.</li><li>Interceptor的实现逻辑更加的清晰简单</li><li>Filter组件更加的通用, 只要支持java servlet的容器都可以使用, 而Interceptor必须依赖于Spring</li><li>Filter的优先级是高于Interceptor, 即请求是先到Filter再到Interceptor的, 因为Interceptor的实现主体还是一个servlet</li><li>Filter 不能使用 spring</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;过滤器（Filter）&lt;/li&gt;
&lt;li&gt;拦截器（Interceptor&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Filter是servlet规范中定义的java web组件, 在所有支持java web的容器中都可以使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Filter和Filter Chain是密不可分的, Filter可以实现依次调用正是因为有了Filter Chain&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1ftsv1u5fihj30hh089abw.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是Filter对请求进行拦截的原理图, 那么java web容器(以tomcat为例子)是如何实现这个功能的呢?&lt;/p&gt;
&lt;p&gt;下面看下Filter和Filter Chain的源码&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Filter Interceptor 过滤器 拦截器" scheme="https://yefan813.github.io/tags/Filter-Interceptor-%E8%BF%87%E6%BB%A4%E5%99%A8-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM之 GC 调优步骤</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM4/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM4/</id>
    <published>2018-07-29T13:34:22.000Z</published>
    <updated>2018-08-31T07:24:37.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr25l9g3zj30om0e841i.jpg" alt=""></p><h2 id="初始化设置参数"><a href="#初始化设置参数" class="headerlink" title="初始化设置参数"></a>初始化设置参数</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr26pfc0wj30y008g436.jpg" alt=""></p><h2 id="Parallel-GC-调优的指导原则"><a href="#Parallel-GC-调优的指导原则" class="headerlink" title="Parallel GC 调优的指导原则"></a>Parallel GC 调优的指导原则</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr28i9o7cj30y10feq8j.jpg" alt=""></p><h2 id="G1-调优"><a href="#G1-调优" class="headerlink" title="G1 调优"></a>G1 调优</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftr2el1ajwj30zd0degrk.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr2eug0huj31030ivgqx.jpg" alt=""></p><a id="more"></a><p>参考文档：<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations" target="_blank" rel="noopener">Oracle官网</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="noopener">GC 调优指南</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html" target="_blank" rel="noopener">如何选择垃圾收集器</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations" target="_blank" rel="noopener">G1最佳实践</a><br><a href="https://zhuanlan.zhihu.com/p/22591838" target="_blank" rel="noopener">G1 GC的一些关键技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftr25l9g3zj30om0e841i.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;初始化设置参数&quot;&gt;&lt;a href=&quot;#初始化设置参数&quot; class=&quot;headerlink&quot; title=&quot;初始化设置参数&quot;&gt;&lt;/a&gt;初始化设置参数&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1ftr26pfc0wj30y008g436.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Parallel-GC-调优的指导原则&quot;&gt;&lt;a href=&quot;#Parallel-GC-调优的指导原则&quot; class=&quot;headerlink&quot; title=&quot;Parallel GC 调优的指导原则&quot;&gt;&lt;/a&gt;Parallel GC 调优的指导原则&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftr28i9o7cj30y10feq8j.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;G1-调优&quot;&gt;&lt;a href=&quot;#G1-调优&quot; class=&quot;headerlink&quot; title=&quot;G1 调优&quot;&gt;&lt;/a&gt;G1 调优&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftr2el1ajwj30zd0degrk.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1ftr2eug0huj31030ivgqx.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="GC" scheme="https://yefan813.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC日志分析工具</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM3/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM3/</id>
    <published>2018-07-29T13:14:10.000Z</published>
    <updated>2018-07-29T13:17:23.839Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在线工具：<a href="http://gceasy.io" target="_blank" rel="noopener">http://gceasy.io</a></p></li><li><p>GCViewer</p></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr1n1v45qj30ww0ddaey.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;在线工具：&lt;a href=&quot;http://gceasy.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://gceasy.io&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCViewer&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="GC" scheme="https://yefan813.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾回收算法</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM2/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM2/</id>
    <published>2018-07-29T09:59:14.000Z</published>
    <updated>2018-08-31T07:24:30.084Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqvzd2erdj30zs0datd1.jpg" alt=""></p><p>##标记清楚算法(Mark-Sweep)<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqw93v8ldj30y30ba789.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ftqwdlfu4cj30p40dq0us.jpg" alt=""></p><p>##复制算法(Copying)<br>为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqwirry1nj30l00blac4.jpg" alt=""></p><p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。</p><a id="more"></a><h2 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h2><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqwkj0puvj30ld0cb75n.jpg" alt=""></p><p>缺点：没有内存碎片，但是整理内存比较耗时</p><h2 id="分代收集算法-Generational-Collection"><a href="#分代收集算法-Generational-Collection" class="headerlink" title="分代收集算法(Generational Collection)"></a>分代收集算法(Generational Collection)</h2><p>分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><p>目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftqwmjpuyvj30kg046wfh.jpg" alt=""></p><p>而老生代因为每次只回收少量对象，因而采用Mark-Compact算法。</p><p>另外，不要忘记在<a href="http://www.cnblogs.com/cielosun/p/6622983.html" target="_blank" rel="noopener">Java基础：Java虚拟机(JVM)</a>中提到过的处于方法区的永生代(Permanet Generation)。它用来存储class类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</p><p>对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。如果To Space无法足够存储某个对象，则将这个对象存储到老生代。在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。</p><h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h1><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqwuiheq8j30wl0agq70.jpg" alt=""></p><h1 id="典型的垃圾收集器"><a href="#典型的垃圾收集器" class="headerlink" title="典型的垃圾收集器"></a>典型的垃圾收集器</h1><p>垃圾收集算法是垃圾收集器的理论基础，而垃圾收集器就是其具体实现。下面介绍HotSpot虚拟机提供的几种垃圾收集器。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzmigfi8j30zu08o41k.jpg" alt=""></p><ol><li><p><strong>Serial/Serial Old</strong><br>最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。</p></li><li><p><strong>ParNew</strong><br>Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集。</p></li><li><p><strong>Parallel Scavenge</strong><br>新生代的<strong>并行</strong>收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。</p></li><li><p><strong>Parallel Old</strong><br>Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程。</p></li><li><p><strong>CMS</strong><br>Current Mark Sweep收集器是一种以最小回收时间停顿为目标的<strong>并发</strong>回收器，因而采用Mark-Sweep算法。</p></li><li><p><strong>G1</strong><br>G1(Garbage First)收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。</p></li></ol><h2 id="这里要强调一下并行与并发的概念："><a href="#这里要强调一下并行与并发的概念：" class="headerlink" title="这里要强调一下并行与并发的概念："></a>这里要强调一下并行与并发的概念：</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzpiq83bj30z80clwlo.jpg" alt=""></p><h2 id="停顿时间-VS-吞吐量"><a href="#停顿时间-VS-吞吐量" class="headerlink" title="停顿时间 VS 吞吐量"></a>停顿时间 VS 吞吐量</h2><p> <img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzrdxmovj30w908rdjq.jpg" alt=""></p><h1 id="垃圾收集器搭配"><a href="#垃圾收集器搭配" class="headerlink" title="垃圾收集器搭配"></a>垃圾收集器搭配</h1><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftqzwboe8qj30rc0jkdpn.jpg" alt=""></p><h1 id="垃圾收集器详解："><a href="#垃圾收集器详解：" class="headerlink" title="垃圾收集器详解："></a>垃圾收集器详解：</h1><h2 id="并行垃圾收集器（Parallel-Collector）"><a href="#并行垃圾收集器（Parallel-Collector）" class="headerlink" title="并行垃圾收集器（Parallel Collector）"></a>并行垃圾收集器（Parallel Collector）</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqzz6v7u4j30ri08jtb3.jpg" alt=""></p><h2 id="CMS-垃圾收集器"><a href="#CMS-垃圾收集器" class="headerlink" title="CMS 垃圾收集器"></a>CMS 垃圾收集器</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr01s112jj30hl09m3zp.jpg" alt=""></p><h3 id="CMS-垃圾收集过程"><a href="#CMS-垃圾收集过程" class="headerlink" title="CMS 垃圾收集过程"></a>CMS 垃圾收集过程</h3><ol><li>CMS initialmark： 初始化标记Root， stop the world</li><li>CMS concurrent mark：并发标记</li><li>CMS concurrent preclean：并发预清理</li><li>CMS remark ：重新标记。 stop the world</li><li>CMS concurrent sweep：并发清除</li><li>CMS concurrent reset： 并发重置</li></ol><h3 id="CMS-缺点"><a href="#CMS-缺点" class="headerlink" title="CMS 缺点"></a>CMS 缺点</h3><p>CPU 敏感<br>浮动垃圾<br>空间碎片</p><h3 id="CMS-相关参数"><a href="#CMS-相关参数" class="headerlink" title="CMS 相关参数"></a>CMS 相关参数</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr07yp4fbj30zm0awq6l.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr093dpxoj30yl0dgaep.jpg" alt=""></p><h2 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h2><p>新生代和老年代垃圾收集器</p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftr0dqxjbkj30yf0bd793.jpg" alt=""> </p><h3 id="Mixed-GC："><a href="#Mixed-GC：" class="headerlink" title="Mixed GC："></a>Mixed GC：</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr0fw6h38j30pu05tmyk.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr0gtvi2xj30w80a4dj2.jpg" alt=""></p><h3 id="Mixed-GC-时机："><a href="#Mixed-GC-时机：" class="headerlink" title="Mixed GC 时机："></a>Mixed GC 时机：</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr0hcs8tuj30zc0gjn4x.jpg" alt=""></p><h3 id="Mixed-GC-相关参数："><a href="#Mixed-GC-相关参数：" class="headerlink" title="Mixed GC 相关参数："></a>Mixed GC 相关参数：</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftr0j7fupxj30xt0g479o.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ftr0k5ocwdj30uu04ljt9.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr0lktqmpj30ya0dvwka.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr0mm2vpej30uk0dcn1c.jpg" alt=""></p><p> 参考文章：</p><p> <a href="https://www.cnblogs.com/cielosun/p/6674431.html" target="_blank" rel="noopener">JVM垃圾回收算法</a></p><p> <a href="https://blog.csdn.net/aijiudu/article/details/72991993" target="_blank" rel="noopener">JVM架构和GC垃圾回收机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1ftqvzd2erdj30zs0datd1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##标记清楚算法(Mark-Sweep)&lt;br&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftqw93v8ldj30y30ba789.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1ftqwdlfu4cj30p40dq0us.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##复制算法(Copying)&lt;br&gt;为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftqwirry1nj30l00blac4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JVM 垃圾回收 算法" scheme="https://yefan813.github.io/tags/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM之内存结构</title>
    <link href="https://yefan813.github.io/2018/07/29/JVM1/"/>
    <id>https://yefan813.github.io/2018/07/29/JVM1/</id>
    <published>2018-07-29T09:30:38.000Z</published>
    <updated>2018-08-31T07:24:26.380Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqvmlyu0uj30tu0l3tfs.jpg" alt=""></p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqv5mutquj30qy0e9q6b.jpg" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqv92b52xj30z30ajdlk.jpg" alt=""><br><strong>注：线程私有</strong></p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqvbjk29mj30z10b60zf.jpg" alt=""><br><strong>注：线程私有</strong></p><a id="more"></a><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqvd5nd5dj30yw0agwk4.jpg" alt=""></p><p><strong>注：线程共享</strong></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftqvghydnpj30xj08243t.jpg" alt=""></p><p><strong>注：线程共享，JDK8中是 Meta Space ，在 JDK8之前是 Perm Space 永久区</strong></p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftqvin3ygbj30xv07ejwv.jpg" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftqvkjcrq6j30x806mgpu.jpg" alt=""></p><h3 id="非堆区"><a href="#非堆区" class="headerlink" title="非堆区"></a>非堆区</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ftqvpdj5i8j30xe0eagpu.jpg" alt=""></p><p>参考文章：<br><a href="https://blog.csdn.net/aijiudu/article/details/72991993" target="_blank" rel="noopener">JVM架构和GC垃圾回收机制</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">jvm的运行时数据区</a><br><a href="http://ifeve.com/jvm-troubleshooting-guide-4/" target="_blank" rel="noopener">Metaspace</a><br><a href="https://blog.csdn.net/jijijijwwi111/article/details/51564271" target="_blank" rel="noopener">压缩类空间</a><br><a href="https://blog.csdn.net/yandaonan/article/details/50844806" target="_blank" rel="noopener">codecache</a><br><a href="http://engineering.indeedblog.com/blog/2016/09/job-search-web-app-java-8-migration/" target="_blank" rel="noopener">codecache2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftqvmlyu0uj30tu0l3tfs.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行时数据区&quot;&gt;&lt;a href=&quot;#运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区&quot;&gt;&lt;/a&gt;运行时数据区&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftqv5mutquj30qy0e9q6b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftqv92b52xj30z30ajdlk.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;注：线程私有&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;虚拟机栈&quot;&gt;&lt;a href=&quot;#虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈&quot;&gt;&lt;/a&gt;虚拟机栈&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftqvbjk29mj30z10b60zf.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;注：线程私有&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JVM 内存结构" scheme="https://yefan813.github.io/tags/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之六：JVM Heap Dump（堆转储文件）的生成和内存分析工具MAT的使用</title>
    <link href="https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%906/"/>
    <id>https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%906/</id>
    <published>2018-07-26T10:06:22.000Z</published>
    <updated>2018-08-31T07:24:15.684Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/30/53562102.html" target="_blank" rel="noopener">传送门</a></p><p>前面的文章详细讲述了分析Thread Dump文件，实际在处理Java内存泄漏问题的时候，还需要分析JVM堆转储文件来进行定位</p><h2 id="JVM-Heap-Dump（堆转储文件）的生成"><a href="#JVM-Heap-Dump（堆转储文件）的生成" class="headerlink" title="JVM Heap Dump（堆转储文件）的生成"></a>JVM Heap Dump（堆转储文件）的生成</h2><p>正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况。<br>可以通过以下几种方式生成Heap Dump文件：</p><h3 id="使用-jmap-命令生成"><a href="#使用-jmap-命令生成" class="headerlink" title="使用 jmap 命令生成"></a>使用 jmap 命令生成</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html" target="_blank" rel="noopener">jmap</a> 命令是JDK提供的用于生成堆内存信息的工具，可以执行下面的命令生成Heap Dump：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap-dump.bin &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>其中的pid是JVM进程的id，<strong>heap-dump.bin</strong>是生成的文件名称，在执行命令的目录下面。推荐此种方法。</p><h3 id="使用-JConsole-生成"><a href="#使用-JConsole-生成" class="headerlink" title="使用 JConsole 生成"></a>使用 JConsole 生成</h3><p>JConsole是JDK提供的一个基于GUI查看JVM系统信息的工具，既可以管理本地的JVM，也可以管理远程的JVM，可以通过下图的 <strong>dumpHeap</strong> 按钮生成 Heap Dump文件。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/c78c2ca6e71557f5fd118a0a4f80903f.png" alt=""></p><h2 id="在JVM中增加参数生成"><a href="#在JVM中增加参数生成" class="headerlink" title="在JVM中增加参数生成"></a>在JVM中增加参数生成</h2><p>在JVM的配置参数中可以添加 <strong>-XX:+HeapDumpOnOutOfMemoryError</strong> 参数，当应用抛出 OutOfMemoryError 时自动生成dump文件；<br>在JVM的配置参数中添加 <strong>-Xrunhprof:head=site</strong> 参数，会生成java.hprof.txt 文件，不过这样会影响JVM的运行效率，不建议在生产环境中使用（未亲测）。</p><h2 id="常见的Heap-Dump文件分析工具"><a href="#常见的Heap-Dump文件分析工具" class="headerlink" title="常见的Heap Dump文件分析工具"></a>常见的Heap Dump文件分析工具</h2><p>JVM Heap Dump文件可以使用常用的分析工具如下：</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html" target="_blank" rel="noopener">jhat</a> 是JDK自带的用于分析JVM Heap Dump文件的工具，使用下面的命令可以将堆文件的分析结果以HTML网页的形式进行展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat &lt;heap-dump-file&gt;</span><br></pre></td></tr></table></figure><p>其中 heap-dump-file 是文件的路径和文件名，可以使用 <strong>-J-Xmx512m</strong> 参数设置命令的内存大小。执行成功之后显示如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p>这个时候访问 <a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a> 就可以看到结果了。</p><h3 id="Eclipse-Memory-Analyzer-MAT"><a href="#Eclipse-Memory-Analyzer-MAT" class="headerlink" title="Eclipse Memory Analyzer(MAT)"></a>Eclipse Memory Analyzer(MAT)</h3><p><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">Eclipse Memory Analyzer(MAT)</a>是Eclipse提供的一款用于Heap Dump文件的工具，操作简单明了，下面将详细进行介绍。</p><h3 id="IBM-Heap-Analyzer"><a href="#IBM-Heap-Analyzer" class="headerlink" title="IBM Heap Analyzer"></a>IBM Heap Analyzer</h3><p><a href="https://www.ibm.com/developerworks/community/alphaworks/tech/heapanalyzer" target="_blank" rel="noopener">IBM Heap Analyzer</a> 是IBM公司推出的一款用于分析Heap Dump信息的工具，下载之后是一个jar文件，执行结果如下：</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/9ab49abb09fb99a66bf2612989e630c2.png" alt=""></p><h2 id="Memory-Analyzer的安装和使用"><a href="#Memory-Analyzer的安装和使用" class="headerlink" title="Memory Analyzer的安装和使用"></a>Memory Analyzer的安装和使用</h2><p>如前文所述，Eclipse Memory Analyzer（简称MAT）是一个功能丰富且操作简单的JVM Heap Dump分析工具，可以用来辅助发现内存泄漏减少内存占用。<br>使用 Memory Analyzer 来分析生产环境的 Java 堆转储文件，可以从数以百万计的对象中快速计算出对象的 Retained Size，查看是谁在阻止垃圾回收，并自动生成一个 Leak Suspect（内存泄露可疑点）报表。</p><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>Eclipse Memory Analyzer（MAT）支持两种安装方式，一是Eclipse插件的方式，另外一个就是独立运行的方式，建议使用独立运行的方式。<br>在 <a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">http://www.eclipse.org/mat/downloads.php</a> 下载安装MAT，启动之后打开 File - Open Heap Dump… 菜单，然后选择生成的Heap DUmp文件，选择 “Leak Suspects Report”，然后点击 “Finish” 按钮。<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/7ac5ffafea8488aa36df72fd0a8a2df6.png" alt=""></p><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>第一次打开因为需要分析dump文件，所以需要等待一段时间进行分析，分析完成之后dump文件目录下面的文件信息如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/56ae33d76a59bff56b92de705f3e0fc1.png" alt=""></p><p>上图中 heap-27311.bin 文件是原始的Heap Dump文件，zip文件是生成的html形式的报告文件。</p><p>打开之后，主界面如下所示：</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/47fb011d433ddf4c295f4718adc8b4b5.png" alt=""></p><p>接下来介绍界面中常用到的功能：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/843eb07db5728ab786cfbcb016d6809f.png" alt=""></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Overview视图，即概要界面，显示了概要的信息，并展示了MAT常用的一些功能。</p><ul><li>Details 显示了一些统计信息，包括整个堆内存的大小、类（Class）的数量、对象（Object）的数量、类加载器（Class Loader)的数量。</li><li>Biggest Objects by Retained Size 使用饼图的方式直观地显示了在JVM堆内存中最大的几个对象，当光标移到饼图上的时候会在左边Inspector和Attributes窗口中显示详细的信息。</li><li>Actions 这里显示了几种常用到的操作，算是功能的快捷方式，包括 Histogram、Dominator Tree、Top Consumers、Duplicate Classes，具体的含义和用法见下面；</li><li>Reports 列出了常用的报告信息，包括 Leak Suspects和Top Components，具体的含义和内容见下；</li><li>Step By Step 以向导的方式引导使用功能。</li></ul><h3 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h3><p>直方图，可以查看每个类的实例（即对象）的数量和大小。</p><h3 id="Dominator-Tree"><a href="#Dominator-Tree" class="headerlink" title="Dominator Tree"></a>Dominator Tree</h3><p>支配树，列出Heap Dump中处于活跃状态中的最大的几个对象，默认按 retained size进行排序，因此很容易找到占用内存最多的对象。</p><h3 id="OQL"><a href="#OQL" class="headerlink" title="OQL"></a>OQL</h3><p>MAT提供了一个对象查询语言（OQL），跟SQL语言类似，将类当作表、对象当作记录行、成员变量当作表中的字段。通过OQL可以方便快捷的查询一些需要的信息，是一个非常有用的工具。</p><h3 id="Thread-Overview"><a href="#Thread-Overview" class="headerlink" title="Thread Overview"></a>Thread Overview</h3><p>此工具可以查看生成Heap Dump文件的时候线程的运行情况，用于线程的分析。</p><h3 id="Run-Expert-System-Test"><a href="#Run-Expert-System-Test" class="headerlink" title="Run Expert System Test"></a>Run Expert System Test</h3><p>可以查看分析完成的HTML形式的报告，也可以打开已经产生的分析报告文件，子菜单项如下图所示<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/22d20d2d807b24c859b795846f587922.png" alt=""></p><p>常用的主要有Leak Suspects和Top Components两种报告：</p><ul><li>Leak Suspects 可以说是非常常用的报告了，该报告分析了 Heap Dump并尝试找出内存泄漏点，最后在生成的报告中对检测到的可疑点做了详细的说明；</li><li>Top Components 列出占用总堆内存超过1%的对象。</li></ul><h3 id="Open-Query-Browser"><a href="#Open-Query-Browser" class="headerlink" title="Open Query Browser"></a>Open Query Browser</h3><p>提供了在分析过程中用到的工具，通常都集成在了右键菜单中，在后面具体举例分析的时候会做详细的说明。如下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/c9f7a5b311c473627ddd281f52907e0a.png" alt=""><br>这里仅针对在 Overview 界面中的 Acations中列出的两项进行说明：</p><p>Top Consumers 按类、类加载器和包分别进行查询，并以饼图的方式列出最大的几个对象。菜单打开方式如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/5e7a1762e03b51c263cb713f64461135.png" alt=""></p><p>Duplicate Classes 列出被加载多次的类，结果按类加载器进行分组，目标是加载同一个类多次被类加载器加载。使用该工具很容易找到部署应用的时候使用了同一个库的多个版本。菜单打开方式如下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/cc8cbe62f8e41bb9da95edeba1a25a1b.png" alt=""></p><h3 id="Find-Object-by-address"><a href="#Find-Object-by-address" class="headerlink" title="Find Object by address"></a>Find Object by address</h3><p>通过十六进制的地址查找对应的对象，见下图：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/27e4a4532a75590d7e3a66f7101c9240.png" alt=""></p><p>参考资料：<br><a href="http://blog.csdn.net/zapldy/article/details/7727572" target="_blank" rel="noopener">利用MemoryAnalyzer进行OutOfMemoryError的诊断分析</a><br><a href="https://eclipsesource.com/blogs/2013/01/21/10-tips-for-using-the-eclipse-memory-analyzer/" target="_blank" rel="noopener">10 Tips for using the Eclipse Memory Analyzer</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/" target="_blank" rel="noopener">使用 Eclipse Memory Analyzer 进行堆转储文件分析</a><br><a href="http://www.cnblogs.com/xianzhedeyu/p/5800666.html" target="_blank" rel="noopener">Java内存分析</a><br><a href="http://tivan.iteye.com/blog/1487855" target="_blank" rel="noopener">一次使用Eclipse Memory Analyzer分析Tomcat内存溢出</a><br><a href="http://wensong.iteye.com/blog/1986449" target="_blank" rel="noopener">Memory Analyzer Tool 使用手记</a><br><a href="http://www.zhyea.com/2016/07/17/memory-analyzer-all.html" target="_blank" rel="noopener">MemoryAnalyzer介绍及使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/30/53562102.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面的文章详细讲述了分析Thread Dump文件，实际在处理Java内存泄漏问题的时候，还需要分析JVM堆转储文件来进行定位&lt;/p&gt;
&lt;h2 id=&quot;JVM-Heap-Dump（堆转储文件）的生成&quot;&gt;&lt;a href=&quot;#JVM-Heap-Dump（堆转储文件）的生成&quot; class=&quot;headerlink&quot; title=&quot;JVM Heap Dump（堆转储文件）的生成&quot;&gt;&lt;/a&gt;JVM Heap Dump（堆转储文件）的生成&lt;/h2&gt;&lt;p&gt;正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况。&lt;br&gt;可以通过以下几种方式生成Heap Dump文件：&lt;/p&gt;
&lt;h3 id=&quot;使用-jmap-命令生成&quot;&gt;&lt;a href=&quot;#使用-jmap-命令生成&quot; class=&quot;headerlink&quot; title=&quot;使用 jmap 命令生成&quot;&gt;&lt;/a&gt;使用 jmap 命令生成&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jmap&lt;/a&gt; 命令是JDK提供的用于生成堆内存信息的工具，可以执行下面的命令生成Heap Dump：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MAT 内存泄漏" scheme="https://yefan813.github.io/tags/MAT-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之五：常见的Thread Dump日志案例分析</title>
    <link href="https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%905/"/>
    <id>https://yefan813.github.io/2018/07/26/jvm%E5%86%85%E5%AD%98%E5%88%86%E6%9E%905/</id>
    <published>2018-07-26T09:10:11.000Z</published>
    <updated>2018-08-31T07:24:12.229Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/26/08572060.html" target="_blank" rel="noopener">传送门</a></p><h2 id="症状及解决方案"><a href="#症状及解决方案" class="headerlink" title="症状及解决方案"></a>症状及解决方案</h2><p>下面列出几种常见的症状即对应的解决方案：</p><h3 id="CPU占用率很高，响应很慢"><a href="#CPU占用率很高，响应很慢" class="headerlink" title="CPU占用率很高，响应很慢"></a>CPU占用率很高，响应很慢</h3><p>按照<a href="https://yefan813.github.io/2018/07/25/jstack%E4%BD%BF%E7%94%A8/">《Java内存泄漏分析系列之一：使用jstack定位线程堆栈信息》</a>中所说的方法，先找到占用CPU的进程，然后再定位到对应的线程，最后分析出对应的堆栈信息。<br>在同一时间多次使用上述的方法，然后进行对比分析，从代码中找到问题所在的原因。如果线程指向的是”VM Thread”或者无法从代码中直接找到原因，就需要进行内存分析，具体的见下一篇文章。</p><a id="more"></a><h3 id="CPU占用率不高，但响应很慢"><a href="#CPU占用率不高，但响应很慢" class="headerlink" title="CPU占用率不高，但响应很慢"></a>CPU占用率不高，但响应很慢</h3><p>在整个请求的过程中多次执行Thread Dump然后进行对比，取得<strong>BLOCKED</strong> 状态的线程列表，通常是因为线程停在了I/O、数据库连接或网络连接的地方。</p><h3 id="关注点概况"><a href="#关注点概况" class="headerlink" title="关注点概况"></a>关注点概况</h3><p>在Thread Dump文件中，线程的状态分成两种：<strong>Native Thread Status（系统线程状态）</strong>和<strong>JVM Thread Status（JVM 线程状态）</strong>，具体的含义可以参考<a href="https://yefan813.github.io/2018/07/26/jstack3/">上一篇文章</a>。在分析日志的时候需要重点关注如下几种线程状态：</p><h3 id="系统线程状态为-deadlock"><a href="#系统线程状态为-deadlock" class="headerlink" title="系统线程状态为 deadlock"></a>系统线程状态为 deadlock</h3><p>线程处于死锁状态，将占用系统大量资源。</p><h3 id="系统线程状态为-waiting-for-monitor-entry-或-in-Object-wait"><a href="#系统线程状态为-waiting-for-monitor-entry-或-in-Object-wait" class="headerlink" title="系统线程状态为 waiting for monitor entry 或 in Object.wait()"></a>系统线程状态为 waiting for monitor entry 或 in Object.wait()</h3><p>如上一篇文章中所说，系统线程处于这种状态说明它在等待进入一个临界区，此时JVM线程的状态通常都是 <strong>java.lang.Thread.State: BLOCKED。</strong></p><p>如果大量线程处于这种状态的话，可能是一个全局锁阻塞了大量线程。如果短期内多次打印Thread Dump信息，发现<strong>waiting for monitor entry</strong>状态的线程越来越多，没有减少的趋势，可能意味着某些线程在临界区里呆得时间太长了，以至于越来越多新线程迟迟无法进入。</p><h3 id="系统线程状态为-waiting-on-condition"><a href="#系统线程状态为-waiting-on-condition" class="headerlink" title="系统线程状态为 waiting on condition"></a>系统线程状态为 waiting on condition</h3><p>系统线程处于此种状态说明它在等待另一个条件的发生来唤醒自己，或者自己调用了sleep()方法。此时JVM线程的状态通常是java.lang.Thread.State: WAITING (parking)（等待唤醒条件）或java.lang.Thread.State: TIMED_WAITING (parking或sleeping)（等待定时唤醒条件）。</p><p>如果大量线程处于此种状态，说明这些线程又去获取第三方资源了，比如第三方的网络资源或读取数据库的操作，长时间无法获得响应，导致大量线程进入等待状态。因此，这说明系统处于一个网络瓶颈或读取数据库操作时间太长。</p><h3 id="系统线程状态为-blocked"><a href="#系统线程状态为-blocked" class="headerlink" title="系统线程状态为 blocked"></a>系统线程状态为 blocked</h3><p>线程处于阻塞状态，需要根据实际情况进行判断。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>下面通过几个案例进行分解来获得解决问题的方法。</p><h3 id="waiting-for-monitor-entry-和-java-lang-Thread-State-BLOCKED"><a href="#waiting-for-monitor-entry-和-java-lang-Thread-State-BLOCKED" class="headerlink" title="waiting for monitor entry 和 java.lang.Thread.State: BLOCKED"></a>waiting for monitor entry 和 java.lang.Thread.State: BLOCKED</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;DB-Processor-13&quot; daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:102)</span><br><span class="line">                - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)</span><br><span class="line">                at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)</span><br><span class="line"></span><br><span class="line">&quot;DB-Processor-14&quot; daemon prio=5 tid=0x003edf98 nid=0xca waiting for monitor entry [0x000000000825f020]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:102)</span><br><span class="line">                - waiting to lock &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.ServiceCnt.getTodayCount(ServiceCnt.java:111)</span><br><span class="line">                at beans.cus.ServiceCnt.insertCount(ServiceCnt.java:43)</span><br><span class="line"></span><br><span class="line">&quot;DB-Processor-3&quot; daemon prio=5 tid=0x00928248 nid=0x8b waiting for monitor entry [0x000000000825d080]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">                at oracle.jdbc.driver.OracleConnection.isClosed(OracleConnection.java:570)</span><br><span class="line">                - waiting to lock &lt;0xe03ba2e0&gt; (a oracle.jdbc.driver.OracleConnection)</span><br><span class="line">                at beans.ConnectionPool.getConnection(ConnectionPool.java:112)</span><br><span class="line">                - locked &lt;0xe0386580&gt; (a java.util.Vector)</span><br><span class="line">                - locked &lt;0xe0375410&gt; (a beans.ConnectionPool)</span><br><span class="line">                at beans.cus.Cue_1700c.GetNationList(Cue_1700c.java:66)</span><br><span class="line">                at org.apache.jsp.cue_1700c_jsp._jspService(cue_1700c_jsp.java:120)</span><br></pre></td></tr></table></figure><p>上面系统线程的状态是 <strong>waiting for monitor entry</strong>，说明此线程通过 synchronized(obj) { } 申请进入临界区，但obj对应的 Monitor 被其他线程所拥有，所以 JVM线程的状态是 <strong>java.lang.Thread.State: BLOCKED (on object monitor)</strong>，说明线程等待资源超时。</p><p>下面的 <strong>waiting to lock <0xe0375410></0xe0375410></strong> 说明线程在等待给 <strong>0xe0375410</strong> 这个地址上锁（<strong>trying to obtain 0xe0375410 lock</strong>），如果在日志中发现有大量的线程都在等待给 现有大量的线程都在等 上锁的话，这个时候需要在日志中查找那个线程获取了这个锁 <strong>locked <0xe0375410></0xe0375410></strong>，如上面的例子中是 <strong>“DB-Processor-14”</strong> 这个线程，这样就可以顺藤摸瓜了。上面的例子是因为获取数据库操作等待的时间太长所致的，这个时候就需要修改数据库连接的配置信息。</p><p>如果两个线程相互都被对方的线程锁锁住，这样就造成了 <strong>死锁</strong> 现象，如下面的例子所示：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-deadlock-1.png" alt=""></p><h3 id="waiting-on-condition-和-java-lang-Thread-State-TIMED-WAITING"><a href="#waiting-on-condition-和-java-lang-Thread-State-TIMED-WAITING" class="headerlink" title="waiting on condition 和 java.lang.Thread.State: TIMED_WAITING"></a>waiting on condition 和 java.lang.Thread.State: TIMED_WAITING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">                at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">                - parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">                at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</span><br><span class="line">                at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>JVM线程的状态是 java.lang.Thread.State: TIMED_WAITING (parking)，说明线程处于定时等待的状态，parking指线程处于挂起中。</p><p><strong>waiting on condition</strong>需要结合堆栈中的 parking to wait for <0x00000000acd84de8> (a java.util.concurrent.SynchronousQueue$TransferStack) 一起来分析。首先，本线程肯定是在等待某个条件的发生来把自己唤醒。其次，SynchronousQueue并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中的时候必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。</0x00000000acd84de8></p><p>in Object.wait() 和 java.lang.Thread.State: TIMED_WAITING</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;RMI RenewClean-[172.16.5.19:28475]&quot; daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">                at java.lang.Object.wait(Native Method)</span><br><span class="line">                - waiting on &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">                at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</span><br><span class="line">                - locked &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">                at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>本例中JVM线程的状态是 <strong>java.lang.Thread.State: TIMED_WAITING (on object monitor)</strong>，说明线程调用了 <strong>java.lang.Object.wait(long timeout)</strong> 方法而进入了等待状态。</p><p>“Wait Set”中等待的线程状态就是 <strong>in Object.wait()</strong>，当线程获得了 Monitor进入临界区之后，如果发现线程继续运行的条件没有满足，它就调用对象（通常是被 synchronized 的对象）的wait()方法，放弃了Monitor，进入 “Wait Set” 队列中。只有当别的线程在该对象上调用了 notify()或notifyAll()方法， “Wait Set” 队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到的运行态。</p><p>另外需要注意的是，是先 locked <0x00000000aa672478> 然后再 waiting on <0x00000000aa672478>，之所以如此，可以通过下面的代码进行演示：</0x00000000aa672478></0x00000000aa672478></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static private class  Lock &#123; &#125;;</span><br><span class="line">private Lock lock = new Lock();</span><br><span class="line">public Reference&lt;? extends T&gt; remove(long timeout) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">        if (r != null) return r;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            // ……</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在执行的过程中，先用 synchronized 获得了这个对象的 Monitor（对应 locked <0x00000000aa672478>），当执行到 <strong>lock.wait(timeout);</strong> 的时候，线程就放弃了Monitor的所有权，进入 “Wait Set” 队列（对应 waiting on <0x00000000aa672478>）。</0x00000000aa672478></0x00000000aa672478></p><p>前面几篇文章详细说明了如何分析Thread Dump文件，除此之外还可以通过分析JVM堆内存信息来进一步找到问题的原因。</p><p>参考资料：<br><a href="http://just2do.iteye.com/blog/2275894" target="_blank" rel="noopener">性能分析之– JAVA Thread Dump 分析综述</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">三个实例演示 Java Thread Dump 日志分析</a><br><a href="http://sesame.iteye.com/blog/428012" target="_blank" rel="noopener">如何分析Java虚拟机死锁</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/03/18/tda.html" target="_blank" rel="noopener">各种 Java Thread State 第一分析法则</a><br><a href="https://dzone.com/articles/how-analyze-java-thread-dumps" target="_blank" rel="noopener">How to Analyze Java Thread Dumps | 中文版</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr034.html" target="_blank" rel="noopener">官网</a><br><a href="https://mp.weixin.qq.com/s/GsxeFM7QWuR--Kbpb7At2w" target="_blank" rel="noopener">java线程状态转化</a><br><a href="https://blogs.oracle.com/poonam/understanding-cms-gc-logs" target="_blank" rel="noopener">CMS日志格式</a><br><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs" target="_blank" rel="noopener">G1日志格式</a><br><a href="http://gceasy.io/" target="_blank" rel="noopener">GC日志分析工具</a><br><a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener">GCViewer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/26/08572060.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;症状及解决方案&quot;&gt;&lt;a href=&quot;#症状及解决方案&quot; class=&quot;headerlink&quot; title=&quot;症状及解决方案&quot;&gt;&lt;/a&gt;症状及解决方案&lt;/h2&gt;&lt;p&gt;下面列出几种常见的症状即对应的解决方案：&lt;/p&gt;
&lt;h3 id=&quot;CPU占用率很高，响应很慢&quot;&gt;&lt;a href=&quot;#CPU占用率很高，响应很慢&quot; class=&quot;headerlink&quot; title=&quot;CPU占用率很高，响应很慢&quot;&gt;&lt;/a&gt;CPU占用率很高，响应很慢&lt;/h3&gt;&lt;p&gt;按照&lt;a href=&quot;https://yefan813.github.io/2018/07/25/jstack%E4%BD%BF%E7%94%A8/&quot;&gt;《Java内存泄漏分析系列之一：使用jstack定位线程堆栈信息》&lt;/a&gt;中所说的方法，先找到占用CPU的进程，然后再定位到对应的线程，最后分析出对应的堆栈信息。&lt;br&gt;在同一时间多次使用上述的方法，然后进行对比分析，从代码中找到问题所在的原因。如果线程指向的是”VM Thread”或者无法从代码中直接找到原因，就需要进行内存分析，具体的见下一篇文章。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JVM 内存泄露" scheme="https://yefan813.github.io/tags/JVM-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之三：jstack生成的Thread Dump日志线程状态</title>
    <link href="https://yefan813.github.io/2018/07/26/jstack3/"/>
    <id>https://yefan813.github.io/2018/07/26/jstack3/</id>
    <published>2018-07-26T02:57:37.000Z</published>
    <updated>2018-08-31T07:24:02.277Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/20/12131956.html" target="_blank" rel="noopener">传送门</a></p><p>前面<a href="https://yefan813.github.io/2018/07/25/jstack2/">文章</a>中只分析了Thread Dump日志文件的结构，今天针对日志文件中 Java EE middleware, third party &amp; custom application Threads 部分线程的状态进行详细的分析。</p><a id="more"></a><h2 id="Thread-Dump日志的线程信息"><a href="#Thread-Dump日志的线程信息" class="headerlink" title="Thread Dump日志的线程信息"></a>Thread Dump日志的线程信息</h2><p>以下面的日志为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;resin-22129&quot; daemon prio=10 tid=0x00007fbe5c34e000 nid=0x4cb1 waiting on condition [0x00007fbe4ff7c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:315)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.park(ResinThread2.java:196)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.runTasks(ResinThread2.java:147)</span><br><span class="line">    at com.caucho.env.thread2.ResinThread2.run(ResinThread2.java:118)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;Timer-20&quot; daemon prio=10 tid=0x00007fe3a4bfb800 nid=0x1a31 in Object.wait() [0x00007fe3a077a000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)</span><br><span class="line">    at java.util.TimerThread.mainLoop(Timer.java:552)</span><br><span class="line">    - locked &lt;0x00000006f0620ff0&gt; (a java.util.TaskQueue)</span><br><span class="line">    at java.util.TimerThread.run(Timer.java:505)</span><br></pre></td></tr></table></figure><p>以上依次是：</p><ul><li><strong>“resin-22129” 线程名称：</strong>如果使用 java.lang.Thread 类生成一个线程的时候，线程名称为 Thread-(数字) 的形式，这里是resin生成的线程；</li><li><strong>daemon 线程类型：</strong>线程分为守护线程 (daemon) 和非守护线程 (non-daemon) 两种，通常都是守护线程；</li><li><strong>prio=10 线程优先级：</strong>默认为5，数字越大优先级越高；</li><li><strong>tid=0x00007fbe5c34e000 JVM线程的id：</strong>JVM内部线程的唯一标识，通过 java.lang.Thread.getId()获取，通常用自增的方式实现；</li><li><strong>nid=0x4cb1 系统线程id：</strong>对应的系统线程id（Native Thread ID)，可以通过 top 命令进行查看，线程id是十六进制的形式；</li><li><strong>waiting on condition 系统线程状态：</strong>这里是系统的线程状态，具体的含义见下面 系统线程状态 部分；</li><li><strong>[0x00007fbe4ff7c000] 起始栈地址：</strong>线程堆栈调用的其实内存地址；</li><li><strong>java.lang.Thread.State: WAITING (parking) JVM线程状态：</strong>这里标明了线程在代码级别的状态，详细的内容见下面的 JVM线程运行状态 部分。</li><li><strong>线程调用栈信息：</strong>下面就是当前线程调用的详细栈信息，用于代码的分析。堆栈信息应该从下向上解读，因为程序调用的顺序是从下向上的。</li></ul><h2 id="系统线程状态-Native-Thread-Status"><a href="#系统线程状态-Native-Thread-Status" class="headerlink" title="系统线程状态 (Native Thread Status)"></a>系统线程状态 (Native Thread Status)</h2><p>系统线程有如下状态：</p><h3 id="deadlock"><a href="#deadlock" class="headerlink" title="deadlock"></a>deadlock</h3><p>死锁线程，一般指多个线程调用期间进入了相互资源占用，导致一直等待无法释放的情况。</p><h3 id="runnable"><a href="#runnable" class="headerlink" title="runnable"></a>runnable</h3><p>一般指该线程正在执行状态中，该线程占用了资源，正在处理某个操作，如通过SQL语句查询数据库、对某个文件进行写入等。</p><h3 id="blocked"><a href="#blocked" class="headerlink" title="blocked"></a>blocked</h3><p>线程正处于阻塞状态，指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。</p><h3 id="waiting-on-condition"><a href="#waiting-on-condition" class="headerlink" title="waiting on condition"></a>waiting on condition</h3><p>线程正处于等待资源或等待某个条件的发生，具体的原因需要结合下面堆栈信息进行分析。</p><p>（1）如果堆栈信息明确是应用代码，则证明该线程正在等待资源，一般是大量读取某种资源且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取，或者正在等待其他线程的执行等。</p><p>（2）如果发现有大量的线程都正处于这种状态，并且堆栈信息中得知正等待网络读写，这是因为网络阻塞导致线程无法执行，很有可能是一个网络瓶颈的征兆：</p><p>网络非常繁忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；<br>网络可能是空闲的，但由于路由或防火墙等原因，导致包无法正常到达；<br>所以一定要结合系统的一些性能观察工具进行综合分析，比如netstat统计单位时间的发送包的数量，看是否很明显超过了所在网络带宽的限制；观察CPU的利用率，看系统态的CPU时间是否明显大于用户态的CPU时间。这些都指向由于网络带宽所限导致的网络瓶颈。</p><p>（3）还有一种常见的情况是该线程在 sleep，等待 sleep 的时间到了，将被唤醒。</p><h3 id="waiting-for-monitor-entry-或-in-Object-wait"><a href="#waiting-for-monitor-entry-或-in-Object-wait" class="headerlink" title="waiting for monitor entry 或 in Object.wait()"></a>waiting for monitor entry 或 in Object.wait()</h3><p>Moniter 是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者class的锁，每个对象都有，也仅有一个 Monitor。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/java-monitor.png" alt=""></p><p>从上图可以看出，每个Monitor在某个时刻只能被一个线程拥有，该线程就是 “Active Thread”，而其他线程都是 “Waiting Thread”，分别在两个队列 “Entry Set”和”Waint Set”里面等待。其中在 “Entry Set” 中等待的线程状态是 <strong>waiting for monitor entry</strong>，在 “Wait Set” 中等待的线程状态是 <strong>in Object.wait()</strong> 。</p><h4 id="（1）”Entry-Set”里面的线程。"><a href="#（1）”Entry-Set”里面的线程。" class="headerlink" title="（1）”Entry Set”里面的线程。"></a>（1）”Entry Set”里面的线程。</h4><p>我们称被 synchronized 保护起来的代码段为临界区，对应的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程申请进入临界区时，它就进入了 “Entry Set” 队列中，这时候有两种可能性：</p><ol><li>该Monitor不被其他线程拥有，”Entry Set”里面也没有其他等待的线程。本线程即成为相应类或者对象的Monitor的Owner，执行临界区里面的代码；此时在Thread Dump中显示线程处于 “Runnable” 状态。</li><li>该Monitor被其他线程拥有，本线程在 “Entry Set” 队列中等待。此时在Thread Dump中显示线程处于 “waiting for monity entry” 状态。</li></ol><p>临界区的设置是为了保证其内部的代码执行的原子性和完整性，但因为临界区在任何时间只允许线程串行通过，这和我们使用多线程的初衷是相反的。如果在多线程程序中大量使用synchronized，或者不适当的使用它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在Thread Dump中发现这个情况，应该审视源码并对其进行改进。</p><h4 id="（2）”Wait-Set”里面的线程"><a href="#（2）”Wait-Set”里面的线程" class="headerlink" title="（2）”Wait Set”里面的线程"></a>（2）”Wait Set”里面的线程</h4><p>当线程获得了Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（通常是被synchronized的对象）的wait()方法，放弃Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify()或者notifyAll()方法，”Wait Set”队列中的线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。”Wait Set”中的线程在Thread Dump中显示的状态为 in Object.wait()。通常来说，</p><p>通常来说，当CPU很忙的时候关注 Runnable 状态的线程，反之则关注 waiting for monitor entry 状态的线程。</p><h2 id="JVM线程运行状态-JVM-Thread-Status"><a href="#JVM线程运行状态-JVM-Thread-Status" class="headerlink" title="JVM线程运行状态 (JVM Thread Status)"></a>JVM线程运行状态 (JVM Thread Status)</h2><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-state-diagram.png" alt=""></p><p>在 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">java.lang.Thread.State</a> 中定义了线程的状态：</p><p>详细如下：<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ftnm3dmli7j30w20mf7bd.jpg" alt=""></p><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>至今尚未启动的线程的状态。线程刚被创建，但尚未启动。</p><h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>可运行线程的线程状态。线程正在JVM中执行，有可能在等待操作系统中的其他资源，比如处理器。</p><h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>受阻塞并且正在等待监视器的某一线程的线程状态。处于受阻塞状态的某一线程正在等待监视器锁，以便进入一个同步的块/方法，或者在调用 Object.wait 之后再次进入同步的块/方法。<br>在Thread Dump日志中通常显示为 java.lang.Thread.State: BLOCKED (on object monitor) 。</p><h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>某一等待线程的线程状态。线程正在无期限地等待另一个线程来执行某一个特定的操作，线程因为调用下面的方法之一而处于等待状态：</p><ul><li>不带超时的 Object.wait 方法，日志中显示为 java.lang.Thread.State: WAITING (on object monitor)</li><li>不带超时的 Thread.join 方法</li><li>LockSupport.park 方法，日志中显示为 java.lang.Thread.State: WAITING (parking)</li></ul><h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>指定了等待时间的某一等待线程的线程状态。线程正在等待另一个线程来执行某一个特定的操作，并设定了指定等待的时间，线程因为调用下面的方法之一而处于定时等待状态：</p><ul><li>Thread.sleep 方法</li><li>指定超时值的 Object.wait 方法</li><li>指定超时值的 Thread.join 方法</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>线程处于终止状态。</p><p>根据Java Doc中的说明，在给定的时间上，一个只能处于上述的一种状态之中，并且这些状态都是JVM的状态，跟操作系统中的线程状态无关。</p><h2 id="线程状态样例"><a href="#线程状态样例" class="headerlink" title="线程状态样例"></a>线程状态样例</h2><h3 id="等待状态样例"><a href="#等待状态样例" class="headerlink" title="等待状态样例"></a>等待状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-waiting-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;IoWaitThread&quot; prio=6 tid=0x0000000007334800 nid=0x2b3c waiting on condition [0x000000000893f000]</span><br><span class="line">  java.lang.Thread.State: WAITING (parking)</span><br><span class="line">               at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">               - parking to wait for  &lt;0x00000007d5c45850&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">               at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)</span><br><span class="line">               at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)</span><br><span class="line">               at java.util.concurrent.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:440)</span><br><span class="line">               at java.util.concurrent.LinkedBlockingDeque.take(LinkedBlockingDeque.java:629)</span><br><span class="line">               at com.nbp.theplatform.threaddump.ThreadIoWaitState$IoWaitHandler2.run(ThreadIoWaitState.java:89)</span><br><span class="line">               at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>上面例子中，IoWaitThread 线程保持等待状态并从 LinkedBlockingQueue 接收消息，如果 LinkedBlockingQueue 一直没有消息，该线程的状态将不会改变。</p><h3 id="阻塞状态样例"><a href="#阻塞状态样例" class="headerlink" title="阻塞状态样例"></a>阻塞状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-blocked-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&quot;BLOCKED_TEST pool-1-thread-1&quot; prio=6 tid=0x0000000006904800 nid=0x28f4 runnable [0x000000000785f000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">                at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">                at java.io.FileOutputStream.write(FileOutputStream.java:282)</span><br><span class="line">                at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)</span><br><span class="line">                at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:123)</span><br><span class="line">                - locked &lt;0x0000000780a31778&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">                at java.io.PrintStream.write(PrintStream.java:432)</span><br><span class="line">                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)</span><br><span class="line">                at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:202)</span><br><span class="line">                at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:272)</span><br><span class="line">                at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:85)</span><br><span class="line">                - locked &lt;0x0000000780a040c0&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">                at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:168)</span><br><span class="line">                at java.io.PrintStream.newLine(PrintStream.java:496)</span><br><span class="line">                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)</span><br><span class="line">                at java.io.PrintStream.println(PrintStream.java:687)</span><br><span class="line">                - locked &lt;0x0000000780a04118&gt; (a java.io.PrintStream)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:44)</span><br><span class="line">                - locked &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState$1.run(ThreadBlockedState.java:7)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - &lt;0x0000000780a31758&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">&quot;BLOCKED_TEST pool-1-thread-2&quot; prio=6 tid=0x0000000007673800 nid=0x260c waiting for monitor entry [0x0000000008abf000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:43)</span><br><span class="line">                - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState$2.run(ThreadBlockedState.java:26)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - &lt;0x0000000780b0c6a0&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br><span class="line">&quot;BLOCKED_TEST pool-1-thread-3&quot; prio=6 tid=0x00000000074f5800 nid=0x1994 waiting for monitor entry [0x0000000008bbf000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState.monitorLock(ThreadBlockedState.java:42)</span><br><span class="line">                - waiting to lock &lt;0x0000000780a000b0&gt; (a com.nbp.theplatform.threaddump.ThreadBlockedState)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadBlockedState$3.run(ThreadBlockedState.java:34)</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886</span><br><span class="line">                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - &lt;0x0000000780b0e1b8&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</span><br></pre></td></tr></table></figure><p>在上面的例子中，BLOCKED_TEST pool-1-thread-1 线程占用了 <0x0000000780a000b0> 锁，然而 BLOCKED_TEST pool-1-thread-2 和 BLOCKED_TEST pool-1-thread-3 threads 正在等待获取锁。</0x0000000780a000b0></p><h3 id="死锁状态样例"><a href="#死锁状态样例" class="headerlink" title="死锁状态样例"></a>死锁状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-deadlock-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&quot;DEADLOCK_TEST-1&quot; daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting for monitor entry [0x000000000805f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)</span><br><span class="line">                - waiting to lock &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)</span><br><span class="line">                - locked &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - None</span><br><span class="line"></span><br><span class="line">&quot;DEADLOCK_TEST-2&quot; daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting for monitor entry [0x000000000815f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)</span><br><span class="line">                - waiting to lock &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)</span><br><span class="line">                - locked &lt;0x00000007d58f5e60&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - None</span><br><span class="line"></span><br><span class="line">&quot;DEADLOCK_TEST-3&quot; daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting for monitor entry [0x000000000825f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)</span><br><span class="line">                - waiting to lock &lt;0x00000007d58f5e48&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)</span><br><span class="line">                - locked &lt;0x00000007d58f5e78&gt; (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">                - None</span><br></pre></td></tr></table></figure><p>上面的例子中，当线程 A 需要获取线程 B 的锁来继续它的任务，然而线程 B 也需要获取线程 A 的锁来继续它的任务的时候发生的。在 thread dump 中，你能看到 DEADLOCK_TEST-1 线程持有 0x00000007d58f5e48 锁，并且尝试获取 0x00000007d58f5e60 锁。你也能看到 DEADLOCK_TEST-2 线程持有 0x00000007d58f5e60，并且尝试获取 0x00000007d58f5e78，同时 DEADLOCK_TEST-3 线程持有 0x00000007d58f5e78，并且在尝试获取 0x00000007d58f5e48 锁，如你所见，每个线程都在等待获取另外一个线程的锁，这状态将不会被改变直到一个线程丢弃了它的锁。</p><h3 id="无限等待的Runnable状态样例"><a href="#无限等待的Runnable状态样例" class="headerlink" title="无限等待的Runnable状态样例"></a>无限等待的Runnable状态样例</h3><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/thread-dump-runnable-waiting-status.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;socketReadThread&quot; prio=6 tid=0x0000000006a0d800 nid=0x1b40 runnable [0x00000000089ef000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">                at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">                at java.net.SocketInputStream.read(SocketInputStream.java:129)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)</span><br><span class="line">                - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.read0(StreamDecoder.java:107)</span><br><span class="line">                - locked &lt;0x00000007d78a2230&gt; (a java.io.InputStreamReader)</span><br><span class="line">                at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:93)</span><br><span class="line">                at java.io.InputStreamReader.read(InputStreamReader.java:151)</span><br><span class="line">                at com.nbp.theplatform.threaddump.ThreadSocketReadState$1.run(ThreadSocketReadState.java:27)</span><br><span class="line">                at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure><p>上例中线程的状态是RUNNABLE，但在下面的堆栈日志中发现socketReadThread 线程正在无限等待读取 socket，因此不能单纯通过线程的状态来确定线程是否处于阻塞状态，应该根据详细的堆栈信息进行分析。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://www.theserverside.com/discussions/thread/61915.html" target="_blank" rel="noopener">100% CPU diagnosis</a><br><a href="http://blog.csdn.net/yanghongchang_/article/details/42004883" target="_blank" rel="noopener">JVM调优总结 + jstat 分析</a><br><a href="http://blog.csdn.net/wuzhilon88/article/details/49201891" target="_blank" rel="noopener">JVM调优总结(这个总结得比较全面)</a><br><a href="http://pengjiaheng.iteye.com/blog/search?query=JVM%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">JVM调优总结系列文章</a><br><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2036387.html" target="_blank" rel="noopener">JVM系列一：JVM内存组成及分配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/20/12131956.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面&lt;a href=&quot;https://yefan813.github.io/2018/07/25/jstack2/&quot;&gt;文章&lt;/a&gt;中只分析了Thread Dump日志文件的结构，今天针对日志文件中 Java EE middleware, third party &amp;amp; custom application Threads 部分线程的状态进行详细的分析。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java 内存 jstack thread dump 内存泄露" scheme="https://yefan813.github.io/tags/java-%E5%86%85%E5%AD%98-jstack-thread-dump-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄漏分析系列之四：jstat命令的使用及VM Thread分析</title>
    <link href="https://yefan813.github.io/2018/07/26/jstat-command/"/>
    <id>https://yefan813.github.io/2018/07/26/jstat-command/</id>
    <published>2018-07-25T17:10:07.000Z</published>
    <updated>2018-08-31T07:24:07.012Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.javatang.com/archives/2017/10/25/36441958.html" target="_blank" rel="noopener">传送门</a></p><p>前面提到了一个使用jstack的shell脚本，通过命令可以很快地定位到指定线程对应的堆栈信息。</p><h2 id="使用jstat命令"><a href="#使用jstat命令" class="headerlink" title="使用jstat命令"></a>使用jstat命令</h2><p>当服务器CPU100%的时候，通过定位占用资源最大的线程定位到 VM Thread：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;VM Thread&quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable</span><br></pre></td></tr></table></figure><a id="more"></a><p>这个时候需要使用 jstat -gc <pid> <period> <times> 命令查看gc的信息，显示结果如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/jstat-gc-result-1.jpg" alt=""></times></period></pid></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU      OC         OU       PC        PU       YGC     YGCT    FGC   FGCT       GCT</span><br><span class="line">64.0   64.0   0.0    0.0   332992.0   0.0    666304.0   73192.5   83968.0   83967.9   6893   17.576  6882   2705.923  2723.499</span><br></pre></td></tr></table></figure><p>结果中每个项目的含义可以参考官方对<a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html" target="_blank" rel="noopener">jstat</a>的文档，简单翻译如下：</p><ul><li>S0C: Young Generation第一个survivor space的内存大小 (kB).</li><li>S1C: Young Generation第二个survivor space的内存大小 (kB).</li><li>S0U: Young Generation第一个Survivor space当前已使用的内存大小 (kB).</li><li>S1U: Young Generation第二个Survivor space当前已经使用的内存大小 (kB).</li><li>EC: Young Generation中eden space的内存大小 (kB).</li><li>EU: Young Generation中Eden space当前已使用的内存大小 (kB).</li><li>OC: Old Generation的内存大小 (kB).</li><li>OU: Old Generation当前已使用的内存大小 (kB).</li><li>PC: Permanent Generation的内存大小 (kB)</li><li>PU: Permanent Generation当前已使用的内存大小 (kB).</li><li>YGC: 从启动到采样时Young Generation GC的次数</li><li>YGCT: 从启动到采样时Young Generation GC所用的时间 (s).</li><li>FGC: 从启动到采样时Old Generation GC的次数.</li><li>FGCT: 从启动到采样时Old Generation GC所用的时间 (s).</li><li>GCT: 从启动到采样时GC所用的总时间 (s).</li></ul><p>JDK8的结果稍微有所不同，结果含义可以参考：<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html。" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html。</a></p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>上面中的Young Generation、Permanent Generation和Old Generation等概念有一些混乱，这里简要的进行说明。简单来说，JVM内存由堆（Heap）和非堆（Non-heap）内存组成，前者共运行在JVM之上的程序使用，后者供JVM自己使用。</p><p><img src="https://www.javatang.com/wp-content/uploads/2017/10/r_sun-jdk-memory-area1.png" alt=""></p><p>堆内存的组成如下：<br><img src="https://www.javatang.com/wp-content/uploads/2017/10/r_heap1.png" alt=""></p><p>非堆内存由 Permanent Generation 和 Code Cache 两部分组成：</p><ul><li>Permanent Generation（持久代）: 保存虚拟机自己的静态(refective)数据，主要存放加载的Class类级别静态对象如class本身，method，field等等。permanent generation空间不足会引发full GC；</li><li>Code Cache: 用于编译和保存本地代码（native code）的内存，JVM内部处理或优化。</li></ul><h2 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h2><h3 id="堆内存设置"><a href="#堆内存设置" class="headerlink" title="堆内存设置"></a>堆内存设置</h3><ul><li>堆内存（总的）由 -Xms 和 -Xmx 分别设置最小和最大堆内存</li><li>New Generation 由 -Xmn 设置，-XX:SurvivorRatio=m 设置 Eden和 两个Survivor区的大小比值；-XX:NewRatio=n 设置 New Generation 和 Old Generation 的大小比值。</li><li>每个线程的堆栈大小由 ·-Xss· 设置，JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li></ul><h3 id="非堆内存设置"><a href="#非堆内存设置" class="headerlink" title="非堆内存设置"></a>非堆内存设置</h3><p>非堆内存由 -XX:PermSize=n 和 -XX:MaxPermSize=n 分别设置最小和最大非堆内存大小</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>介绍完上面的概念之后，我们再来看最上面的日志信息，有两个地方有问题：<br>一是FGC（完全GC）的数量太大了，正常来说FGC应该占整个GC（YGC+FGC）的1%到5%才正常，上面日志上完全GC的次数太多了；二是日志中PU的值太大了，基本上已经达到设置的PC了，因此需要增大MaxPermSize的值。<br>不过这只是权宜之计，出现这么大的非堆内存，肯定什么地方出现了问题，还需要进一步找到占用内存的原因，这也是后面文章所要说的。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://just2do.iteye.com/blog/2275894" target="_blank" rel="noopener">性能分析之– JAVA Thread Dump 分析综述</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html" target="_blank" rel="noopener">三个实例演示 Java Thread Dump 日志分析</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/archive/2013/03/18/tda.html" target="_blank" rel="noopener">各种 Java Thread State 第一分析法则</a><br><a href="https://dzone.com/articles/how-analyze-java-thread-dumps" target="_blank" rel="noopener">How to Analyze Java Thread Dumps | 中文版</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html" target="_blank" rel="noopener">官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.javatang.com/archives/2017/10/25/36441958.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面提到了一个使用jstack的shell脚本，通过命令可以很快地定位到指定线程对应的堆栈信息。&lt;/p&gt;
&lt;h2 id=&quot;使用jstat命令&quot;&gt;&lt;a href=&quot;#使用jstat命令&quot; class=&quot;headerlink&quot; title=&quot;使用jstat命令&quot;&gt;&lt;/a&gt;使用jstat命令&lt;/h2&gt;&lt;p&gt;当服务器CPU100%的时候，通过定位占用资源最大的线程定位到 VM Thread：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;VM Thread&amp;quot; prio=10 tid=0x00007fbea80d3800 nid=0x5e9 runnable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="java 内存 jstat JVM" scheme="https://yefan813.github.io/tags/java-%E5%86%85%E5%AD%98-jstat-JVM/"/>
    
  </entry>
  
</feed>
